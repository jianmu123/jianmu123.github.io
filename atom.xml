<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jianmu123.github.io/</id>
    <title>Personal blog</title>
    <updated>2020-10-14T15:13:15.071Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jianmu123.github.io/"/>
    <link rel="self" href="https://jianmu123.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jianmu123.github.io/images/avatar.png</logo>
    <icon>https://jianmu123.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Personal blog</rights>
    <entry>
        <title type="html"><![CDATA[面向对象编程]]></title>
        <id>https://jianmu123.github.io/post/mian-xiang-dui-xiang-bian-cheng/</id>
        <link href="https://jianmu123.github.io/post/mian-xiang-dui-xiang-bian-cheng/">
        </link>
        <updated>2020-10-03T15:05:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数封装重载和面向对象理解">函数封装重载和面向对象理解</h2>
<blockquote>
<p>1:封装：低耦合高内聚。（把实现某个功能的代码进行函数封装）</p>
<p>2：多态：重载和重写：</p>
<ul>
<li>重载：方法名相同，但是形参在不同个数或类型的时候执行<strong>不同的方法</strong>（后端）。而JS中是不一样的，JS中的重载指的是<strong>同一个方法</strong>，根据传参的不同实现出不同的效果。</li>
<li>重写：在类的继承中，子类可以重写父类中的方法。</li>
</ul>
<p>3：继承：子类继承父类的方法（目的：让子类的实例能够调取父类中的属性和方法）。</p>
</blockquote>
<ul>
<li><strong>原型继承</strong>  :<strong>让父类中的属性和方法在子类实例的原型上。</strong>（父类私有的和公有的都是子类公有的）</li>
</ul>
<p><strong>实现方法</strong></p>
<p>​				      <strong>Child.prototype= new Parent()。</strong></p>
<p>​					  <strong>Child.prototype.constructor=Child;(保证原型重新定向后的完整性),因为前面将prototype指向了一个新实例。</strong></p>
<p><em><strong>特点</strong></em>：</p>
<p>​			1：不像其他语言中的继承（其他语言的继承一般是拷贝。也就是说子类继承父类，会把父类中的属性和方法拷贝一份到子类中，供子类调取使用），它是把父类的原型放到了子类实例上的原型链上，实例调取这些方法是基于__proto__原型链查找机制完成的。</p>
<p>​			 2：子类可以重写父类的方法（这样会导致父类的其他实例也受到影响，严格来说不合理了）。</p>
<p>​			 3：父类中的私有或则公有的属性方法，<strong>最后都会变成子类中的公有属性和方法。</strong></p>
<pre><code class="language-javascript">function A(x){//父
    this.x=x;
}
A.prototype.getX=function(){
    console.log(this.x);
}
function B(y){//子
    this.y=y;
}
//要想B的实例实现A的方法需要如下操作(原型)：
B.prototype=new A(200);
B.prototype.constructor=B;//保证原型的完整性

B.prototype.getY=function(){
    console.log(this.y);
}
let b1=new B(100);
b1.getY();//100
b1.getX();//200

//重写create方法
Object.create= function create(obj){
    function Fn(){};
    Fn.prototype=obj;
    return new Fn();
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1602687978470.png" alt="" loading="lazy"></figure>
<ul>
<li><em><strong>call继承</strong></em>（父类私有的是子类私有的）</li>
</ul>
<p><strong><em>实现方法</em>：</strong></p>
<p>​		<strong>Child方法中把Parent当作普通函数执行，并且让Parent中的this通过call方法指向Child的实例，相当于在给Child的实例中设置了很多Parent的私有属性或则方法。</strong></p>
<p><em><strong>特点：</strong></em></p>
<p>​			1：只能继承父类的<strong>私有属性和方法</strong>（因为是把Parent当作普通函数执行，和其原型上的属性和方法没有关系）。父类的私有变为子类私有，但是和公有的没有关系。</p>
<pre><code class="language-javascript">function A(x){//父
    this.x=x;
}
A.prototype.getX=function(){
    console.log(this.x);
}
//要想B的实例实现A的方法需要如下操作（call继承）：
function B(y){//子
    //this指向了B的实例（b1）
    A.call(this,200);//即：b1.x=200;
    this.y=y;
}

B.prototype.getY=function(){
    console.log(this.y);
}
let b1=new B(100);
b1.y;
b1.getY();//100
b1.getX();//200
</code></pre>
<ul>
<li><strong>寄生组合继承</strong>：（推荐，父类私有的是子类私有的，父类公有的是子类公有的）</li>
</ul>
<p>实现方法：call继承+类似与原型继承</p>
<p>特点：父类私有和公有的分别是子类实例的<strong>私有和公有属性方法</strong></p>
<pre><code class="language-javascript">function A(x){// 父类
    this.x=x;
}
A.prototype.getX=function(){
    console.log(this.x);
}
//要想B的实例实现A的方法需要如下操作（call继承）：只能继承私有的
function B(y){// 子类
    //this指向了B的实例（b1）
    A.call(this,200);//即：b1.x=200;让b1有A的私有属性
    this.y=y;
}
//类似于原型继承（继承了公有的），注意create方法不兼容，在最后重写了兼容的create方法。
//craete方法：创建一个空对象，让空对象的__proto__指向第一个参数
B.prototype=Object.create(A.prototype);
B.prototype.constructor=B;//(保证完整性)

B.prototype.getY=function(){
    console.log(this.y);
}
let b1=new B(100);
b1.y;
b1.getY();//100
b1.getX();//200
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1602688196114.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>ES6中的extend继承（extends和super）</strong>：</p>
<p>其实原理是寄生组合方式。实现了父类私有的是子类私有的，父类公有的是子类公有的。</p>
<pre><code class="language-javascript">class A{
    constructor(x){
        this.x=x;
    }
    getX(){
        console.log(this.y);
    }
}
//extends 相当于原型继承：B.prototype.__proto__=A.prototype
class B extends A{
    constructor(y){
        super(200);//凡是继承了的都必须把super()写在constructor的里面的第一句。它的作用相当于：A.call(this,200)
        this.y=y;
    }
    getY(){
        console.log(this.y);
    }
}
let b1= new B(100);
console.log(b1);
</code></pre>
</li>
</ul>
<h3 id="什么是面向对象">什么是面向对象？</h3>
<blockquote>
<p>面向对象是一种编程思想，和面向过程是对应的，JS本身就是基于面向对象构建出来的。（比如JS中有很多内置类，像Promise就是ES6中新增的一个内置类，我们可以基于new Promise来创建一个实例，来管理异步编程）<br>
JS面向对象和其他编程语言还是有略微不同的，JS中类和实例是基于原型和原型链机制来处理的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数执行机制]]></title>
        <id>https://jianmu123.github.io/post/han-shu-zhi-xing-ji-zhi/</id>
        <link href="https://jianmu123.github.io/post/han-shu-zhi-xing-ji-zhi/">
        </link>
        <updated>2020-10-02T15:21:09.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">var n=2;
var obj={
    n:3;
    fn:(function(n){
        n*=2;
        this.n+=2;
        var n=5;
        return function(){
            this.n*=2;
            console.log(m+(++n));
        }
    })(n)
};
var fn=obj.fn;
fn(3);//9
obj.fn(3);//10
console.log(n,obj.n);//8 6
</code></pre>
<p>1代码执行形成一个全局作用域；</p>
<p>2然后变量提升：var n;var obj; var fn;</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CL2871%5CDesktop%5C%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="全局作用域" loading="lazy"></figure>
<p>3然后代码自生而下执行：</p>
<p>3.1:n=2；</p>
<p>3.2:obj是一个引用类型所以<strong>开辟一个堆内存</strong>，<strong>然后把键值对依次存入堆内存</strong>，最后把堆地址给obj（注意因为后面有自执行函数，所以要等自执行函数执行完）</p>
<p>3.2.1: n=3；</p>
<p>3.2.2:fn：自执行函数的返回值；(自执行函数又会形成一个<strong>私有作用域</strong>，如图：AA)</p>
<p>3.2.2.1： 自执行函数执行</p>
<blockquote>
<p>注意：自执行函数如果没有执行完的话，当前的堆内存是没有存完的，那么图片种的aaafff000和obj是没有关系的，此时obj是undefined（只有自执行函数执行了把它的返回值赋值给fn）<br>
<img src="https://jianmu123.github.io//post-images/1602687805805.png" alt="" loading="lazy"></p>
</blockquote>
<p>自执行函数执行第一步：形参赋值 第二步：变量提升 第三步：代码自上而下执行</p>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1602687817264.png" alt="" loading="lazy"></figure>
<p>到此自执行函数执行完了，然后obj也赋值了，接着执行fn=obj.fn；fn(3);obj.fn(3);console.log(n,obj.n);</p>
<p><strong>fn(3)执行图：</strong></p>
<figure data-type="image" tabindex="3"><img src="https://jianmu123.github.io//post-images/1602687826347.png" alt="" loading="lazy"></figure>
<p><strong>obj.fn(3)执行图：</strong><br>
<img src="https://jianmu123.github.io//post-images/1602687839196.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6_02]]></title>
        <id>https://jianmu123.github.io/post/es6_02/</id>
        <link href="https://jianmu123.github.io/post/es6_02/">
        </link>
        <updated>2020-09-29T13:14:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="箭头函数">箭头函数</h2>
<blockquote>
<p>简化了函数创建代码，真实项目是和普通函数混用。</p>
</blockquote>
<pre><code class="language-javascript">1： const fn=([形参])=&gt;{
    //函数体
    return n*10;
}
//箭头函数的创建都是函数表达式方式（变量=函数），这种模式下，不存在变量提升，所以，函数只能在创建完成后执行（即：在创建的代码后面执行）。
fn([实参]);

//形参只有一个，则小括号可以不加
const fn1=n=&gt;{
    return n*10;
};
//如果函数体只有一句话，并且是return xxx；则可以省略大括号和return
const fn2=n=&gt;n*10;
举例：
	function fn3(n){
        return function(m){
            return m+(n++);
        }
    }
改写为箭头函数：
第一步改写(箭头代替function)：
	const fn3=n=&gt;{
        return m=&gt;{
             return m+(n++);
        } 
    }
第二步改写：
	const fn3=n=&gt;{
        return  m=&gt;m+(n++);
    }
最后： const fn3=n=&gt;m=&gt;m+(n++);    
</code></pre>
<h3 id="箭头函数没有arguments但是可以基于剩余运算符获取实参集合而且es6中是支持给形参设置默认值的">箭头函数没有arguments，但是可以基于剩余运算符获取实参集合，而且ES6中是支持给形参设置默认值的。</h3>
<pre><code class="language-javascript">let fn=(context)=&gt;{
    console.log(arguments);
};
fn(1);//报错，arguments不存在
但是使用剩余运算符，可以获取和arguments一样的值

let obj = {};
let fn = (c = window, ...arg) =&gt; { //c=window:意思是调用函数的时候不传值，则c指的默认值是window，而arg是传的剩余值
   console.log(c, arg); //Object Array(3)
 };
fn(obj, 10, 20, 30); //c=obj  arg=[10,20,30]是一个数组
fn(); //不传值： c=Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}   arg=[]
</code></pre>
<h3 id="箭头函数没有自己的this它里面用到的this都是自己所处上下文执行环境的this真实项目中一旦涉及this问题注意箭头函数的使用">箭头函数没有自己的this，它里面用到的this都是自己所处上下文(执行环境)的this，真实项目中一旦涉及this问题，注意箭头函数的使用。</h3>
<pre><code class="language-javascript">        let obj = {
            name: &quot;珠峰&quot;,
            fn: function () {
                let f = () =&gt; {
                    console.log(this.name); //自己所处上下文的this  
                }
                f(); //f执行，它的this是obj
            }
        }
        obj.fn(); //&quot;珠峰&quot;

1：箭头函数加普通函数
        let obj1 = {
            b1: 1,
            a1: function () {
                setTimeout(() =&gt; { //没有this，自己家没有就好像上面找,找到a1的this（obj）
                    console.log(this);
                    this.b1 = &quot;珠峰&quot;;
                }, 1000)
            }
        }
        obj1.a1();//obj

2：全箭头函数
        let obj2 = {
            b2: 1,
            a2: () =&gt; {
                setTimeout(() =&gt; { //没有this，自己家没有就好像上面找，找到全局的this（window）
                    console.log(this);
                }, 1000)
            }
        }
        obj2.a2(); //Window 
3：全普通函数
      let obj = {
            b: 1,
            a: function () {
                // let that = this; //使that变量指向obj
                setTimeout(function () {//因为定时器方法其实是window的方法
                    console.log(this);
                }, 1000)
            }
        }
        obj.a(); //Window/obj
</code></pre>
<h3 id="的作用">&quot;...&quot; 的作用</h3>
<ul>
<li>扩展运算符（多用在解构赋值中）</li>
<li>展开运算符 （多用在传递实参中）</li>
<li>剩余运算符（多用在接收实参中）</li>
</ul>
<pre><code class="language-javascript">//1:作为扩展运算符（解构赋值）：
	let [n,...m]=[12,23,34];//n=12,m=[23,34]

//2:作为展开运算符（传递实参）：
	let ary=[12,23,34,45];
    let min=Math.min(...ary);//..ary就是ary的每个值
	//还可以用作数组/对象克隆（浅克隆）,并且可以添加值和属性：
	let cloneAry=[...ary];
	let obj={name:&quot;圆圆&quot;,
            age:41};
	let cloneObj=[...obj,sex:'girl'];//在原来基础上添加了sex属性

//3：作为剩余运算符（接收实参）
	 let fn=(...arg)=&gt;{
        console.log(arg); //arg:[10,20,30];
     }
     fn(10,20,30);
</code></pre>
<h3 id="class创建类">class创建类</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6_01]]></title>
        <id>https://jianmu123.github.io/post/es6_01/</id>
        <link href="https://jianmu123.github.io/post/es6_01/">
        </link>
        <updated>2020-09-28T12:13:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="let关键字">let关键字</h3>
<p>let关键字用于声明变量，它的作用域在块级作用域中（{}内部）。</p>
<p>使用var声明的变量在全局中也可以访问 。</p>
<p>使用区别(作用域不同)：</p>
<pre><code class="language-javascript">for(var i=0;i&lt;3;i++){
  i++;  
};
console.log(i); =&gt;4

for(let i=0;i&lt;3;i++){
i++;
};
console.log(i); =&gt;报错:i is not defined
</code></pre>
<h4 id="特点">特点：</h4>
<ul>
<li><strong>防止了循环变量变成了全局变量，可以结局作用域污染问题</strong>。</li>
<li><strong>作用域是块级作用域</strong>。</li>
<li><strong>在同一个作用域中，一个变量只能声明一次。</strong></li>
<li><strong>没有变量提升</strong>。（<strong>即：使用let的变量只能先声明在使用</strong>）</li>
</ul>
<pre><code class="language-javascript">  console.log(i);=&gt;不会报错，但是打印的是undefined
      var i = 10; 

  console.log(i);=&gt;会报错:i is not defined
      let i = 10; 
</code></pre>
<ul>
<li><strong>解决typeof的暂时性死区</strong></li>
</ul>
<pre><code class="language-javascript">  var num1 = 10;
      if (true) {
        console.log(num1); //报错（暂时性死区），而使用typeof不会报错
        let num1 = 5;
      }
</code></pre>
<pre><code class="language-javascript">    var arr = [];
      for (var i = 0; i &lt; 3; i++) {
        arr[i] = function () {
          console.log(i);
        };
      }
      arr[0](); //3
      arr[1](); //3

      var arr1 = [];
      for (let i = 0; i &lt; 3; i++) {
        arr1[i] = function () {
          console.log(i);
        };
      }
      arr1[0](); //0
      arr1[1](); //1
//注意：在第二个中：每次循环都会产生一个块级作用域，每个作用域中的变量是不同的，函数执行时输出的时自己上一级（循环产生的块级作用域）作用域的值。
</code></pre>
<p>注意</p>
<pre><code class="language-javascript"> function b() {
        let a = 10;
        var a = 4;
        console.log(a);//报错 a重复声明
      }
</code></pre>
<h3 id="const关键字">const关键字</h3>
<p>作用：声明常量，常量就是值（内存地址），不能修改。</p>
<p>特点：</p>
<ul>
<li>具有块级作用域。</li>
<li>声明常量时必须赋初始值。</li>
<li>声明常量后，值不能修改。</li>
</ul>
<pre><code class="language-javascript">      const a = 5;
      a = 10;//报错，因为修改了pi的内存地址

	  const pi = [100, 200];
      pi[0] = 300;
      pi[1] = 400;
      console.log(pi[0], pi[1]); //300 400,因为没有修改pi的内存地址
      pi = [1, 2];
      console.log(pi[0], pi[1]); //报错，因为修改了pi的内存地址
</code></pre>
<h3 id="解构赋值">解构赋值</h3>
<pre><code class="language-javascript">&lt;script&gt;
      /*
            解构赋值：声明和赋值放在一起
            解构：表示等号左边和右边结构类似
        */
      /* 数组：位置必须相同 */
      let [name0, age0] = [&quot;珠峰&quot;, 9];
      console.log(&quot;姓名：&quot; + name0, &quot;年龄:&quot; + age0); //=&gt; 珠峰 9
      console.log(&quot;age:&quot; + age0); // =&gt; 9
      //就想要age的写法,也必须把name的位置空出来：
      let [, age1] = [&quot;珠峰&quot;, 9];
      console.log(&quot;age1:&quot; + age1); //=&gt;9

      /* 数组有长度，要想获取长度，则是获取对象的长度 */
      //   let [, age2, length] = [&quot;珠峰&quot;, 9];
      //   console.log(age2, length); //=&gt;  9 undefined

      //上面的写法不是对象，正确写法：
      let { length } = [&quot;珠峰&quot;, 1, 2, 3]; //注意这里必须写length，因为长度就是length属性，不能改变
      console.log(&quot;数组长度:&quot; + length); //=&gt;4

      //   如果存在关键字可以采用冒号(:)的形式进行更改名字,如下：default是关键字，在解构中使用冒号更改了名字为d
      let { name3, age3, default: d } = {
        name3: &quot;河马&quot;,
        age3: 10,
        default: &quot;老虎&quot;,
      };
      console.log(d); //老虎

      let [
        ,
        {
          address: [, a],
        },
      ] = [{ name2: &quot;珠峰&quot; }, { age2: 9, address: [1, 2, 3] }]; //这种写法要想获取address中的2，解构赋值这样写： let [,{address:[,a]}]
      console.log(&quot;a:&quot; + a);

      //   如果想设置某个属性的默认值采用=号的形式
      let { name4 = &quot;没有定义&quot;, age4 = &quot;没有定义&quot;, sex4 = &quot;没有定义&quot; } = {
        name4: &quot;兔子&quot;,
        age4: 1,
      };
      console.log(name4, age4, sex4); // =&gt;兔子 1 没有定义
    &lt;/script&gt;
</code></pre>
<h3 id="字符串">字符串</h3>
<pre><code class="language-javascript">&lt;script&gt;
      /*
                es6模板字符串  特殊的字符串
                模板字符串取代了原有的字符串拼接功能(使用反引号)

                  字符串方法：
                          inclueds        是否包含
                          startsWith      是否以xxx开头
                          endsWith        是否以xxx结尾
                          padStart/End    开头/结尾补全
                          注意：这2个方法的参数：padStart([targetLength] [padString])
                                第一个参数：指定的字符串长度，如果输入的比原来字符串长度小，则该方法无作用，如果比它大，则补齐到指定的长度
            */
      let name = &quot;珠峰&quot;;
      let age = 18;
      let str = `hello~${name}今年${age}岁了`;
      //   插入引号：
      let str1 = `hello~'${name}'今年${age}岁了`;
      console.log(str); //hello~珠峰今年18岁了
      console.log(str1); //hello~'珠峰'今年18岁了

      //   举例：
      let ul = &quot;&lt;ul&gt;&quot; + &quot;&lt;li&gt;&quot; + name + &quot;&lt;/li&gt;&quot;;
      &quot;&lt;li&gt;&quot; + age + &quot;&lt;/li&gt;&quot; + &quot;&lt;/ul&gt;&quot;;
      console.log(ul); //&lt;ul&gt;&lt;li&gt;珠峰&lt;/li&gt;   (不支持换行)
      /* 但是想要ul和li直接换行，可以这样： */
      let ul1 = `&lt;ul&gt;
          &lt;li&gt;${name}&lt;/li&gt;
          &lt;li&gt;${age}&lt;/li&gt;
      &lt;/ul&gt;`;
      console.log(ul1);
      /* 结果：
              &lt;ul&gt;
                  &lt;li&gt;珠峰&lt;/li&gt;
                   &lt;li&gt;18&lt;/li&gt;
              &lt;/ul&gt;
             */

      /* 方法的使用
                        字符串方法：
                          inclueds        是否包含
                          startsWith      是否以xxx开头
                          endsWith        是否以xxx结尾
                          padStart/End    开头/结尾补全
                           注意：这2个方法的参数：padStart([targetLength] [padString])
                                第一个参数：指定的字符串长度，如果输入的比原来字符串长度小，则该方法无作用，如果比它大，则补齐到指定的长度
             */
      let url = &quot;https//www.baidu&quot;;
      //   console.log(url.length);16
      console.log(url.includes(&quot;baidu&quot;)); //true
      console.log(url.startsWith(&quot;https&quot;)); //true
      console.log(url.endsWith(&quot;.com&quot;)); //false
      console.log(`${url.toString().padEnd(20, &quot;.coms/log&quot;)}`); //https//www.baidu.com
      //因为原来字符串长度是16，这里设置的20，所以在后面补齐4个字符.com,后面的字符就不会用到
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[call和apply]]></title>
        <id>https://jianmu123.github.io/post/call-he-apply/</id>
        <link href="https://jianmu123.github.io/post/call-he-apply/">
        </link>
        <updated>2020-09-26T14:59:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="call和apply">call和apply</h3>
<p>他们的作用：都能够改变this指向，借用别人函数实现自己的功能。第一个参数将改变this指向.</p>
<p>他们的区别： 第二个参数的传参列表不同， call需要把实参按照形参的个数传进去。</p>
<p>apply需要传一个arguments（数组形式）</p>
<pre><code class="language-javascript">function Person(name,age){
           this.name=name;
           this.age=age;
}
function Person(name,age){
           this.name=name;
           this.age=age;
}
var person=new Person(&quot;张三&quot; ,18);
var obj={
};
 // Person()的执行其实就是调用call方法，等价于Person.call(),但是call方法可以传值，这样就会引起翻天覆地的变化
Person.call(obj,&quot;李四&quot;,18);//this将指向obj
结果：obj;//{name: &quot;李四&quot;, age: 18}

用apply：
Person.apply(obj,[&quot;王五&quot;,52]);
obj;//{name: &quot;王五&quot;, age: 52}
</code></pre>
<p>案列：</p>
<pre><code class="language-javascript">    &lt;script&gt;
      // 下面举例工厂创建car
      //大小
      function Size(width, height, len) {
        this.width = width;
        this.height = height;
        this.len = len;
      }
      //   样式
      function Stytyle(color) {
        this.color = color;
      }
      //能源
      function Energy(gasoline, gas) {
        this.gasoline = gasoline;
        this.gas = gas;
      }
      // 创建汽车
      function Car(width, height, len, color, gasoline, gas) {
        Size.call(this, width, height, len);
        Stytyle.call(this, color);
        Energy.call(this, gasoline, gas);

        // 使用apply,效果是一样的
        /*
        Size.apply(this, [width, height, len]);
        Stytyle.apply(this, [color]);
        Energy.apply(this, [gasoline, gas]);
         */

        /*上面的2个代码相当于在这个Car中写了以下代码 ：
        this.width = width;
        this.height = height;
        this.len = len;
        this.color = color;
        this.gasoline = gasoline;
        this.gas = gas;
          */
      }
      var car = new Car(100, 200, 300, &quot;red&quot;, &quot;汽油&quot;, &quot;天然气&quot;);
      console.log(car);
      /* 
        color: &quot;red&quot;
        gas: &quot;天然气&quot;
        gasoline: &quot;汽油&quot;
        height: 200
        len: 300
        width: 100
     */
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery5]]></title>
        <id>https://jianmu123.github.io/post/jquery5/</id>
        <link href="https://jianmu123.github.io/post/jquery5/">
        </link>
        <updated>2020-09-24T13:30:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1jquery事件处理">1：jQuery事件处理</h2>
<h3 id="1-elementon方法可以绑定多个事件">1： element.on()方法可以绑定多个事件</h3>
<p>语法：element.on(event,[selector],fn);<br>
event是事件类型，[selector]是元素的子元素选择器<br>
您的浏览器不支持 video 标签。<br>
</video></p>
<pre><code class="language-javascript">    $(&quot;div&quot;).on({
        //鼠标经过div背景变红
        mouseenter：function(){
        $(&quot;this&quot;).css(&quot;background&quot;,&quot;red&quot;);
       },
       //鼠标点击div背景变粉红
      click：function(){
          $(&quot;this&quot;).css(&quot;background&quot;,&quot;pink&quot;);
      }
    })
</code></pre>
<p>on方法可以实现事件的委派。例如：</p>
<pre><code class="language-javascript">$(&quot;ul&quot;).on(click,&quot;li&quot;,function(){
    alert(&quot;触发了点击事件&quot;);
});
这个触发事件在ul上，但是触发对象在li上，即ul委托li帮他触发
</code></pre>
<h3 id="2off方法可以移除通过on方法添加的事件处理程序">2:off方法可以移除通过on方法添加的事件处理程序</h3>
<pre><code class="language-javascript"> $(&quot;p&quot;).off()  //解除p上所有的事件处理
 $(&quot;p&quot;).off(&quot;click&quot;) //解除p上的click事件处理
 $(&quot;ul&quot;).off(&quot;click&quot;，&quot;li&quot;) //解除事件委托
</code></pre>
<h3 id="3自动触发事件">3:自动触发事件</h3>
<p>有些事件希望自动触发，比如轮播图的自动播放能跟点击按钮一致，可以利用定时器自动触发按钮按钮点击事件，不必鼠标点击触发。<br>
第一种形式：元素.事件()<br>
第二种形式：元素.trigger(&quot;事件&quot;)<br>
第三种形式：元素.triggerHandler(&quot;事件&quot;)<br>
第三种和前面的区别：不会触发元素的默认行为，比如文本框焦点事件的光标此时不会闪烁</p>
<pre><code class="language-javascript">       下面代码不会有光标闪烁：
       $(&quot;input&quot;).on(&quot;focus&quot;,function(){
           $(&quot;this&quot;).val(&quot;你好吗&quot;);
       })
       $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);//自动触发
</code></pre>
<h3 id="4阻止默认行为和冒泡行为">4：阻止默认行为和冒泡行为</h3>
<h4 id="41阻止默认行为eventpreventdefault-或则return-false">4.1:阻止默认行为：event.preventDefault(); 或则：return false</h4>
<h4 id="42阻止冒泡行为eventstoppropagation">4.2:阻止冒泡行为：event.stopPropagation()</h4>
<p>###5:jQuery对象拷贝<br>
语法：$.extend([deep],target,object1,[objectN]) //[objectN]是代表不仅可以拷贝一个还可以拷贝多个。<br>
<img src="https://jianmu123.github.io//post-images/1600956466981.png" alt="" loading="lazy"><br>
浅拷贝：会覆盖原来数据<br>
深拷贝：会保留原来是数据<br>
<img src="https://jianmu123.github.io//post-images/1600957628103.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600957634129.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery4]]></title>
        <id>https://jianmu123.github.io/post/jquery4/</id>
        <link href="https://jianmu123.github.io/post/jquery4/">
        </link>
        <updated>2020-09-23T13:07:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一jquery元素操作">一jQuery元素操作</h2>
<h3 id="1找父级元素可以通过parent方法但是当父级元素很多的时候可以使用partens方法该方法会获取到所有的祖先元素包括body和html结合siblings方法可以找到该元素所需要的祖先元素">1：找父级元素可以通过parent()方法，但是当父级元素很多的时候可以使用partens()方法，该方法会获取到所有的祖先元素，包括body和html，结合siblings()方法可以找到该元素所需要的祖先元素。</h3>
<pre><code class="language-javascript">  例如:
  var p = $(this).panrent(&quot;.quantity-form&quot;).parent(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();等同于：  var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
</code></pre>
<h3 id="2遍历">2:遍历</h3>
<p>隐式迭代是对同一类元素做了相同的操作，如果想要给同一类元素左不同的操作则需要使用遍历。<br>
遍历使用的是each()方法和$.each()方法。</p>
<h4 id="each方法主要使用在遍历dom对象比如标签">each()方法主要使用在遍历DOM对象，比如标签</h4>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1600867180840.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">   $(&quot;div&quot;).each(function (index, domEle) {
          //回调函数的第一个参数一定是索引号，可以是自己定义的索引名称
          console.log(index); //结果： 0 1 2
          //回调函数的第二个参数一定是DOM对象,可以是自己定义的对象名称
          console.log(domEle); //结果：&lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;
          //domEle.cc(&quot;color&quot;);//会报错，因为DOM对象没有css方法，因此需要转换成JQ对象
          $(&quot;domEle&quot;).css(&quot;color&quot;, &quot;bule&quot;);
        });
</code></pre>
<h4 id="each方法主要是来处理数据的比如数组-对象">$.each()方法：主要是来处理数据的，比如数组、对象。</h4>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1600868203421.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">        var arr = [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;]; //定义数组
        //遍历数组
        $.each(arr, function (index, domEle) {
          console.log(index); //打印索引0 1 2
          console.log(domEle); //打印arr内部值 blue red green
        });
        //遍历对象
        $.each(
          {
            name: &quot;孙悟空&quot;,
            age: 18,
          },
          function (i, ele) {
            console.log(i); //输出name age属性名
            console.log(ele); //输出顺悟空 18属性值
          }
        );
</code></pre>
<h3 id="3创建添加删除元素">3:创建添加删除元素</h3>
<p>创建语法：var li=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">&quot;</mi><mo>&lt;</mo><mi>l</mi><mi>i</mi><mo>&gt;</mo><mi mathvariant="normal">我</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">的</mi><mi>l</mi><mi>i</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mo>&gt;</mo><mi mathvariant="normal">&quot;</mi><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">语</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">：</mi><mo>(</mo><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">匹</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mo>)</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">匹</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mi>u</mi><mi>l</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">原</mi><mi mathvariant="normal">有</mi><mi>l</mi><mi>i</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi>l</mi><mi>i</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">(&quot;&lt;li&gt;我是创建的li&lt;/li&gt;&quot;);
添加语法：内部添加：(添加后是匹配元素的子元素)
       elelment. append()方法，会添加到匹配元素的后面。在ul中原有li后面添加li使用方法：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">语</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">：</span><span class="mopen">(</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mclose">)</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">原</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">：</span></span></span></span>(&quot;ul&quot;).append(li);<br>
elelment.prepend()方法，会添加到匹配元素的前面。在ul中原有li前面添加li使用方法：$(&quot;ul&quot;).prepend(li);<br>
外部添加：(添加后是匹配元素的兄弟元素)<br>
elelment.before()和 elelment.after()。<br>
删除元素:<br>
element.remove();删除匹配元素本身。<br>
element.empty();删除匹配元素集合中的所有子节点。<br>
element.html(&quot;&quot;);清空匹配元素内容。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery3]]></title>
        <id>https://jianmu123.github.io/post/jquery3/</id>
        <link href="https://jianmu123.github.io/post/jquery3/">
        </link>
        <updated>2020-09-22T12:45:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一jquery属性操作">一:jQuery属性操作</h2>
<p>###1：设置或获取元素固有属性值：prop()<br>
所谓元素固有属性值就是元素本身自带的属性，比如<a>标签中的herf。<br>
<img src="https://jianmu123.github.io//post-images/1600865423781.png" alt="" loading="lazy"></p>
<h3 id="2设置或获取元素自定义属性值attr">2：设置或获取元素自定义属性值：attr()</h3>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1600865617914.png" alt="" loading="lazy"></figure>
<h3 id="3数据缓存-data">3:数据缓存 data()</h3>
<p>data()方法可以在指定元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前的存放的数据都会被移除<br>
<img src="https://jianmu123.github.io//post-images/1600866237557.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600866060662.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600866065161.png" alt="" loading="lazy"><br>
购物车案列（不含css部分）</p>
<pre><code class="language-javascript">  &lt;body&gt;
    &lt;div class=&quot;w&quot;&gt;
      &lt;div class=&quot;head&quot;&gt;
        &lt;!-- 全选模块 --&gt;
        &lt;div class=&quot;t-checkbox&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;checkall&quot; /&gt;全选
        &lt;/div&gt;
        &lt;div class=&quot;t-goods&quot;&gt;商品&lt;/div&gt;
        &lt;div class=&quot;t-price&quot;&gt;单价&lt;/div&gt;
        &lt;div class=&quot;t-num&quot;&gt;数量&lt;/div&gt;
        &lt;div class=&quot;t-sum&quot;&gt;小计&lt;/div&gt;
      &lt;/div&gt;
      &lt;!-- 商品模块 --&gt;
      &lt;div class=&quot;cart-item-list&quot;&gt;
        &lt;div class=&quot;cart-check&quot;&gt;
          &lt;div class=&quot;p-checkbox&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt;
          &lt;/div&gt;
          &lt;div class=&quot;p-goodes&quot;&gt;
            &lt;div class=&quot;p-img&quot;&gt;
              &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt;
              洗衣粉
            &lt;/div&gt;
            &lt;div class=&quot;p-price&quot;&gt;￥12.60&lt;/div&gt;
            &lt;div class=&quot;p-num&quot;&gt;
              &lt;div class=&quot;quantity-form&quot;&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt;
                &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;p-sum&quot;&gt;￥12.60&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;cart-item-list&quot;&gt;
        &lt;div class=&quot;cart-check&quot;&gt;
          &lt;div class=&quot;p-checkbox&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt;
          &lt;/div&gt;
          &lt;div class=&quot;p-goodes&quot;&gt;
            &lt;div class=&quot;p-img&quot;&gt;
              &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt;
              消毒水
            &lt;/div&gt;
            &lt;div class=&quot;p-price&quot;&gt;￥15.20&lt;/div&gt;
            &lt;div class=&quot;p-num&quot;&gt;
              &lt;div class=&quot;quantity-form&quot;&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt;
                &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;p-sum&quot;&gt;￥15.20&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;cart-item-list&quot;&gt;
        &lt;div class=&quot;cart-check&quot;&gt;
          &lt;div class=&quot;p-checkbox&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt;
          &lt;/div&gt;
          &lt;div class=&quot;p-goodes&quot;&gt;
            &lt;div class=&quot;p-img&quot;&gt;
              &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt;
              吹风机
            &lt;/div&gt;
            &lt;div class=&quot;p-price&quot;&gt;￥30.50&lt;/div&gt;
            &lt;div class=&quot;p-num&quot;&gt;
              &lt;div class=&quot;quantity-form&quot;&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt;
                &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt;
                &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;p-sum&quot;&gt;￥30.50&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!-- 总计模块 --&gt;
      &lt;div class=&quot;cart-floatbar&quot;&gt;
        &lt;div class=&quot;select-all&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;checkall&quot; /&gt;全选
        &lt;/div&gt;
        &lt;div class=&quot;operation&quot;&gt;
          &lt;a href=&quot;javascript:;&quot; class=&quot;remove-batch&quot;&gt;删除选中的商品&lt;/a&gt;
          &lt;a href=&quot;javascript:;&quot; class=&quot;clear-all&quot;&gt;清除购物车&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;toolbar-right&quot;&gt;
          &lt;div class=&quot;amount-sum&quot;&gt;总计&lt;em&gt; &lt;/em&gt;件商品&lt;/div&gt;
          &lt;div class=&quot;price-sum&quot;&gt;总价：&lt;em&gt;￥&lt;/em&gt;&lt;/div&gt;
          &lt;div class=&quot;btn-area&quot;&gt;
            &lt;a href=&quot;javascript:;&quot; style=&quot;color: red&quot;&gt;去结算&lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
      //实现点击全选框，所有商品全选，或则手动点击了所有商品选中框，上面全选框也选上
      $(function () {
        //入口函数

        //1：全选点击单选框，可以用change事件
        $(&quot;.checkall&quot;).change(function () {
          //   var a = $(this).prop(&quot;checked&quot;);
          //   console.log(a);//结果是点击全选返回ture,证明已经获取到
          $(&quot;.j-checkbox, .checkall&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;)); //下面的按钮根据全选的状态变化而变化
          //所有商品背景变化
          if ($(this).prop(&quot;checked&quot;)) {
            $(&quot;.cart-item-list&quot;).addClass(&quot;beijing&quot;);
          } else {
            $(&quot;.cart-item-list&quot;).removeClass(&quot;beijing&quot;);
          }
        });
        $(&quot;.j-checkbox&quot;).change(function () {
          //如果下面的复选框全部选中，则上面的全选也选中$(&quot;.j-checkbox&quot;).length是所有商品的单选框数量
          if ($(&quot;.j-checkbox:checked&quot;).length == $(&quot;.j-checkbox&quot;).length) {
            //.j-checkbox:checked可以知道到底有几个单选框被选中
            $(&quot;.checkall&quot;).prop(&quot;checked&quot;, true);
          } else {
            $(&quot;.checkall&quot;).prop(&quot;checked&quot;, false);
          }
          if ($(this).prop(&quot;checked&quot;)) {
            $(this).parents(&quot;.cart-item-list&quot;).addClass(&quot;beijing&quot;);
          } else {
            $(this).parents(&quot;.cart-item-list&quot;).removeClass(&quot;beijing&quot;);
          }
        });
        // 2：增减商品数量模块。核心思路：声明一个变量，当我们点击+/-的时候，就让这个值++/--，然后赋给文本框
        $(&quot;.increment&quot;).click(function () {
          //得到当前加/减的兄弟：文本框的值
          var n = $(this).siblings(&quot;.itxt&quot;).val(); //text文本使用val获取内容
          //   console.log(n);
          n++;
          $(this).siblings(&quot;.itxt&quot;).val(n);
          // 3: 根据商品数量自动计算价格,价格是加减号的父亲的父亲的兄弟
          var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
          // console.log(p);
          p = p.substr(1) * n; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算
          p = p.toFixed(2);
          // console.log(p);
          $(this)
            .parents(&quot;.p-num&quot;)
            .siblings(&quot;.p-sum&quot;)
            .html(&quot;￥&quot; + p);
          getSum();
        });
        //3:减：
        $(&quot;.decrement&quot;).click(function () {
          var n = $(this).siblings(&quot;.itxt&quot;).val(); //text文本使用val获取内容，非文本使用text()
          //   console.log(n);
          if (n &gt; 1) {
            n--;
          }
          $(this).siblings(&quot;.itxt&quot;).val(n);
          //  根据商品数量自动计算价格,价格是加减号的父亲的父亲的兄弟
          var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); //获取到了价格
          // console.log(p);
          p = p.substr(1) * n; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算
          p = p.toFixed(2);
          $(this)
            .parents(&quot;.p-num&quot;)
            .siblings(&quot;.p-sum&quot;)
            .html(&quot;￥&quot; + p);
          getSum();
        });
        //4:手动修改文本框的数值使小计跟着改变
        $(&quot;.itxt&quot;).change(function () {
          var m = $(this).val();
          // console.log(m);
          var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
          p = p.substr(1) * m; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算
          p = p.toFixed(2);
          $(this)
            .parents(&quot;.p-num&quot;)
            .siblings(&quot;.p-sum&quot;)
            .html(&quot;￥&quot; + p);
          getSum();
        });
        getSum(); //初始显示选中商品总数和总价
        //5:商品总数模块,定义一个函数，来遍历商品数量和总价
        function getSum() {
          var count = 0;
          var money = 0;
          //获取文本框数量,使用each遍历方法
          $(&quot;.itxt&quot;).each(function (index, ele) {
            //index是索引，ele是dom对象
            // console.log(index);
            // console.log($(ele));
            count += parseInt($(ele).val());
          });
          //修改总数量
          $(&quot;.amount-sum em&quot;).text(count);
          //获取总价
          $(&quot;.p-sum&quot;).each(function (index, ele) {
            money += parseFloat($(ele).text().substr(1));
            // console.log(sum);
            //修改总价钱
            $(&quot;.price-sum em&quot;).text(&quot;￥&quot; + money.toFixed(2));
          });
        }

        // 6:删除模块
        $(&quot;.remove-batch&quot;).click(function () {
          //删除复选框选中的商品
          $(&quot;.j-checkbox:checked&quot;).parents(&quot;.cart-item-list&quot;).remove();
          getSum();
        });
        //清空购物车模块
        $(&quot;.clear-all&quot;).click(function () {
          $(&quot;.cart-item-list&quot;).remove();
          getSum();
        });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery-2]]></title>
        <id>https://jianmu123.github.io/post/jquery-2/</id>
        <link href="https://jianmu123.github.io/post/jquery-2/">
        </link>
        <updated>2020-09-21T09:55:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一jquery的样式操作">一：jQuery的样式操作</h2>
<h3 id="1设置类样式方法">1：设置类样式方法</h3>
<p>作用等同于以前的classList，可以操作类样式，注意jQuery中的类参数不要加点。</p>
<pre><code class="language-javaScript">添加类：$(&quot;div&quot;).addClass(&quot;current&quot;);//这里是给div盒子添加current的类
删除类：$(&quot;div&quot;).removeClss(&quot;current&quot;);//这里是删除div盒子current的类
切换类：$(&quot;div&quot;).toggleClss(&quot;current&quot;);//这里是切换div盒子current的类
    &lt;script&gt;
      $(function () {
        //添加类addClass
        $(&quot;div&quot;).click(function () {
          $(this).addClass(&quot;current&quot;);
        });
        //删除类removeClass
        $(&quot;div&quot;).click(function () {
          $(this).removeClass(&quot;current&quot;);
        });
        //切换类toggleClass
        $(&quot;div&quot;).click(function () {
          $(this).toggleClass(&quot;current&quot;);
        });
      });
    &lt;/script&gt;
</code></pre>
<h3 id="2jquery的类操作是对指定类进行操作不会影响原先类名但是原生js中classname会覆盖元素里面原先的类名">2:jQuery的类操作是对指定类进行操作，不会影响原先类名，但是原生js中className会覆盖元素里面原先的类名。</h3>
<p>下面做一个菜单栏案例：点击菜单后该菜单的内容显示出来，单击其他菜单，之前显示的菜单隐藏。</p>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1600683854568.png" alt="" loading="lazy"></figure>
<h2 id="二jquery效果">二：jQuery效果</h2>
<h3 id="1显示隐藏-切换showspeedeasingcallback-hidespeedeasingcallback-togglespeedeasingcallback-注意这3个方法内部有方括号所以参数都可以不写">1：显示/隐藏 /切换：show([speed],[easing],[callback])  hide([speed],[easing],[callback]) toggle([speed],[easing],[callback])。注意这3个方法内部有方括号[],所以参数都可以不写。</h3>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1600773077471.png" alt="" loading="lazy"></figure>
<h3 id="2下拉上啦切换-slidedownslideupslidetoggle-内部参数与上方一样">2：下拉/上啦/切换: slideDown,slideUp,slideToggle。内部参数与上方一样。</h3>
<h3 id="3事件切换hoveroverout">3：事件切换：hover（[over],out）</h3>
<pre><code>           over:鼠标经过元素上触发，相当于mouseenter
           out:鼠标移出此元素要触发的函数，相当于mouseleave
</code></pre>
<p>区分概念：<br>
1.mouseover与mouseout成对，mouseenter与mouseleave成对<br>
2.mouseover触发优先级高于mouseenter，mouseout触发优先级mouseleave<br>
3.在父元素上绑定mouseover和mouseout事件，子元素同样也会触发，即子元素事件会冒泡至父元素；而父元素绑定mouseenter和mouseleave事件只对父元素有效，子元素不会触发。<br>
<img src="https://jianmu123.github.io//post-images/1600780157055.png" alt="" loading="lazy"></p>
<h3 id="4淡入淡出效果fadein-fadeout-fadetoggle-fadetospeedopacity-内部参数与上方一样">4：淡入淡出效果：fadeIn（）、fadeOut()、fadeToggle()、fadeTo(speed,opacity)。内部参数与上方一样。</h3>
<p><img src="https://jianmu123.github.io//post-images/1600780522485.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600780704256.png" alt="" loading="lazy"></p>
<h3 id="4自定义动画animateparamsspeed-easing-callback">4:自定义动画：animate(params，[speed]、[easing]、[callback])。</h3>
<p><img src="https://jianmu123.github.io//post-images/1600781058456.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600781151512.png" alt="" loading="lazy"></p>
<h3 id="5注意以上所有动画或效果都有动画队列的问题">5：注意以上所有动画或效果都有动画队列的问题。</h3>
<p>问题：动画或则效果一旦触发就会运行，但是当我们多次触发就会造成多个动画或效果的队列问题。<br>
解决办法：在添加stop()方法，把上一个动画效果停止（谁执行了动画效果就在谁前面添加）。<br>
<img src="https://jianmu123.github.io//post-images/1600781449952.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery-1]]></title>
        <id>https://jianmu123.github.io/post/jquery1/</id>
        <link href="https://jianmu123.github.io/post/jquery1/">
        </link>
        <updated>2020-09-20T07:19:25.000Z</updated>
        <content type="html"><![CDATA[<p>一： jQuery的概述</p>
<h3 id="1-jquery是javascript的一个封装库里面存放了很多函数">1. jQuery是javaScript的一个封装库,里面存放了很多函数。</h3>
<h3 id="2-使用时只需调用这个库文件">2. 使用时只需调用这个库文件。</h3>
<h3 id="3-jquery主要是用来操作dom的">3. jQuery主要是用来操作DOM的。</h3>
<h3 id="4-学习jquery的本质是学习调用这些函数">4. 学习jQuery的本质是学习调用这些函数。</h3>
<h2 id="二jquery的基本使用">二：jQuery的基本使用</h2>
<h3 id="1首先官网下载jquery官网httpsjquerycom">1：首先官网下载[jQuery官网]{https://jquery.com/}</h3>
<h3 id="2符号是jquery的别称jquery中的顶级对象相当于javascript中的window对象">2：$符号是jQuery的别称，jQuery中的顶级对象，相当于javaScript中的window对象</h3>
<h3 id="3注意下列">3：注意下列：</h3>
<pre><code class="language-javaScript">//下面是jQuery入口函数
   &lt;script&gt;
      $(function () {
          //内容写这里
      });
    &lt;/script&gt;

 // 1:DOM 对象：用原生js方式获取的对象是DOM对象

   var myDiv = document.querySelector(&quot;div&quot;); //querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。

   console.dir(myDiv); //打印所有的属性和方法

   // 2:jQuery 对象：用原生jQuery方式获取的对象是jQuery对象

   $(&quot;div&quot;);  // jQuery 对象

   console.dir($(&quot;div&quot;));

   //  从控制台可以看出2者打印的内容不同，jQuery打印了一个伪数组的形式

   // 3:jQuery对象只能使用jQuery方法,DOM对象只能使用原生javaScript属性和方法,2者不能混用
</code></pre>
<h3 id="4jquery对象和dom对象的相互转换">4：<strong>jQuery对象和DOM对象的相互转换</strong></h3>
<p>因为原生js比jQuery大，一些原生的js属性方法在jQuery中没有，所以需要把jQuery对象转换为DOM对象才可以使用。</p>
<pre><code class="language-javaScript">先用2种方式获取对象：
 var myDiv = document.querySelector(&quot;div&quot;);//DOM对象
 $(&quot;div&quot;);  // jQuery 对象
//jQuery转DOM(2种方式):
 $('div')[index];//index是索引号，因为jQuery对象是一个伪数组  
 $('div')get（index）;
//DOM转jQuery：
 $(myDiv);   
</code></pre>
<h2 id="三jquery的常用api">三：jQuery的常用API</h2>
<h3 id="1jquery基础选择器">1：jQuery基础选择器</h3>
<pre><code class="language-javaScript"> $('选择器')；//里面选择器直接写CSS选择器即可，但是要加引号。
</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID选择器</td>
<td>$(&quot;#id&quot;)</td>
<td>获取指定的ID元素</td>
</tr>
<tr>
<td>全选选择器</td>
<td>$('*')</td>
<td>匹配所有元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(&quot;.class&quot;)</td>
<td>获取同一类元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(&quot;div&quot;)</td>
<td>获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(&quot;div,p,li&quot;)</td>
<td>选取多个元素</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(&quot;li.current&quot;)</td>
<td>交集元素</td>
</tr>
</tbody>
</table>
<h4 id="2jquery设置css样式">2:jQuery设置css样式：</h4>
<pre><code class="language-javaScript"> $(&quot;div&quot;).css(&quot;属性&quot;,&quot;值&quot;);//例如：$(&quot;div&quot;).css(''background'',''red'');就把所有的div背景改为了红色
注意：这里的属性名一定要加引号

同时修改多个样式：使用对象的形式，注意这个时候属性名就不用加引号,加上也没错
$(&quot;div&quot;).css({
width:400,
height:400,
backgroundColor：&quot;red&quot;，
注意如果是复合属性就要写成驼峰命名法，如果值不是数字则必须使用引号
})
</code></pre>
<p>这个里面有一个<strong>隐式迭代</strong>的概念，他会把所有选取到的所有元素进行循环遍历，依次执行相应的方法。</p>
<h4 id="3jquery筛选选择器">3：jQuery筛选选择器</h4>
<table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>:firsr</td>
<td>$('li':first)</td>
<td>获取第一个li元素</td>
</tr>
<tr>
<td>:last</td>
<td>$('li:last')</td>
<td>获取最后一个li元素</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$(<strong>&quot;li:eq(2)&quot;</strong>)</td>
<td>获取到的li元素中，选择索引号为2的元素 (注意索引号是从0开始的)</td>
</tr>
<tr>
<td>:odd</td>
<td>$(<strong>&quot;li:odd&quot;</strong>)</td>
<td>获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(&quot;li:even&quot;)</td>
<td>获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody>
</table>
<h4 id="4筛选方法注意方法都有括号">4：筛选方法（注意方法都有括号）</h4>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1600606470845.png" alt="" loading="lazy"></figure>
<h4 id="5注意下例的写法">5：注意下例的写法：</h4>
<pre><code class="language-javaScript">//让鼠标经过div使ul显示出来,this是当前元素(即:div)
  $(&quot;div&quot;).mousemove(function () {      
        $(this).children(&quot;ul&quot;).show();
      });
 //鼠标移出就隐藏
 $(&quot;div&quot;).mouseout(function(){
    $(this).children(&quot;ul&quot;).hide();
 })
</code></pre>
]]></content>
    </entry>
</feed>