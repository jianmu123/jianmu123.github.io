<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jianmu123.github.io/</id>
    <title>Personal blog</title>
    <updated>2020-10-06T15:28:13.145Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jianmu123.github.io/"/>
    <link rel="self" href="https://jianmu123.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jianmu123.github.io/images/avatar.png</logo>
    <icon>https://jianmu123.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Personal blog</rights>
    <entry>
        <title type="html"><![CDATA[JS5]]></title>
        <id>https://jianmu123.github.io/post/js5/</id>
        <link href="https://jianmu123.github.io/post/js5/">
        </link>
        <updated>2020-10-06T15:19:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数组中常用的方法">数组中常用的方法</h2>
<ul>
<li>方法的作用和含义</li>
<li>方法的实参（类型和含义）</li>
<li>方法的返回值</li>
<li>原来的数组是否会发生改变</li>
</ul>
<h3 id="1实现数组增删改的方法">1：实现数组增删改的方法</h3>
<blockquote>
<p>这一部分方法都会改变原数组</p>
</blockquote>
<p><code>push</code></p>
<blockquote>
<p>push:向数组末尾增加内容</p>
<p>参数： 多个任意类型</p>
<p>返回值：返回的是新增的数组长度，原来数组会改变。</p>
</blockquote>
<pre><code class="language-javascript">let ary=[10,20];
let res=ary.push(30,'aa',{
    name:&quot;珠峰&quot;
});
console.log(res,ary);
//5（新数组长度）;
0: 10
1: 20
2: 30
3: &quot;aa&quot;
4: {name: &quot;珠峰&quot;}
length: 5
也可以使用原生js增加（但是一次只能加1个），如：
ary[ary.length]=40;//在数组末尾添加
console.log(ary);
</code></pre>
<p><code>unshift</code></p>
<blockquote>
<p>unshift：向数组开始位置增加内容</p>
<p>参数：多个任意类型</p>
<p>返回值： 新增数组长度，会改变原数组</p>
</blockquote>
<pre><code class="language-javascript">let ary=[10,20];
let res=ary.unshift(30,'aa');
console.log(res,ary);
//4;
0: 30
1: &quot;aa&quot;
2: 10
3: 20
length: 4
</code></pre>
<p><code>shift</code></p>
<blockquote>
<p>shift:删除数组第一项</p>
<p>参数：没有</p>
<p>返回值：被删除的那 一项，会改变原数组</p>
</blockquote>
<pre><code class="language-javascript">let ary=[10,20];
let res=ary.shift();
console.log(res,ary);
//10;
0: 20
length: 1
</code></pre>
<p><code>pop</code></p>
<blockquote>
<p>pop:删除数组最后一项</p>
<p>参数：无</p>
<p>返回值：被删除的那 一项，会改变原数组</p>
</blockquote>
<pre><code class="language-java">let ary=[10,20];
let res=ary.pop();
console.log(res,ary);
//20;
0: 10
length: 1
</code></pre>
<p><code>splice</code>实现数组的增加、删除、修改</p>
<blockquote>
<p>splice:实现删除</p>
<p>参数：n,m 都是数字，从<strong>索引n</strong>开始<strong>删除m个元素</strong>（如果不写m，则删除到末尾）</p>
<p>返回值： 把删除的部分用新数组存储起来返回</p>
</blockquote>
<pre><code class="language-javascript">let ary[10,20,30,40,50,60,70,80,90];
let res=ary.splice(2,4);
console.log(res,ary);// [30，40，50，60]  [10，20，70，80，90]
</code></pre>
<blockquote>
<p>splice:实现增加，修改</p>
<p>参数：n,m,x ：从索引为n开始删除m个元素，然后用x占用那个位置</p>
<p>​            n,0,x:    从索引n开始，，一个都不删，把x放到索引n前面</p>
<p>返回值：把删除的部分用新数组村粗起来返回</p>
</blockquote>
<p>splice:实现向数组末尾增加： splice(ary.length,0,'AA);</p>
<p>splice:实现向数组开头追加： splice(0,0,'BB);</p>
<h3 id="2数组的查询和拼接">2:数组的查询和拼接</h3>
<blockquote>
<p>此组的方法：原来数组不会改变</p>
</blockquote>
<p><code>slice</code></p>
<blockquote>
<p>slice 实现数组查询</p>
<p>参数： n,m     从索引n开始，找到索引为m的地方（不含m这一项）,m不写则找到末尾</p>
<p>返回值： 找到的内容以一个新数组的形式返回</p>
</blockquote>
<pre><code class="language-javascript">let ary =[10,20,30,40,50];
let res=ary.slice(1,3);
console.log(res);// [20,30]
//数组的克隆
let res=ary.slice(0);
console.log(res);//[10,20,30,40,50]
</code></pre>
<p><code>concat</code></p>
<blockquote>
<p>concat：实现数组拼接</p>
<p>参数：任意类型值</p>
<p>返回值： 拼接后的新数组（原数组不变）</p>
</blockquote>
<pre><code class="language-javascript">let ary =[10,20,30,40,50];
let res=ary.concat('珠峰');
console.log(res);// [10,20,30,40,50，'珠峰']
</code></pre>
<h3 id="3把数组转换为字符串">3：把数组转换为字符串</h3>
<blockquote>
<p>原数组不变</p>
</blockquote>
<p><code>toString</code></p>
<blockquote>
<p>toString：把数组转换为字符串</p>
<p>参数：无</p>
<p>返回值： 转换后的新字符串，每一项用逗号分隔（原数组不变）</p>
</blockquote>
<pre><code class="language-javascript">let ary =[10,20,30];
let res=ary.toString();
console.log(res);//&quot;10,20,30&quot;
</code></pre>
<p><code>join</code></p>
<blockquote>
<p>join：把数组转换为字符串</p>
<p>参数：指定的分隔符（不指定则是逗号，和tostring一样）</p>
<p>返回值： 转换后的新字符串，每一项用指定分隔符分隔（原数组不变）</p>
</blockquote>
<pre><code class="language-javascript">let ary =[10,20,30];
let res=ary.join();
console.log(res);//&quot;10,20,30&quot;

let res=ary.join(&quot;&quot;);
console.log(res);//&quot;102030&quot;

let res=ary.join(&quot;+&quot;);
console.log(res);//&quot;10+20+30&quot;
console.log(eval(res));// =&gt;60 因为eval可以把字符串转为js表达式执行
</code></pre>
<h3 id="4检测数组是否含有某一项">4:检测数组是否含有某一项</h3>
<p><code>indexOf/lastIndexOf</code>(IE6~8不兼容)</p>
<blockquote>
<p>indexOf/lastIndexOf: 检测当前项在数组中第一次或最后一次出现的位置的索引值。</p>
<p>参数： 要检测的内容</p>
<p>返回值： 这一项出现的位置索引值（数字），如果数组没有这一项返回-1</p>
</blockquote>
<pre><code class="language-javascript">let ary=[10,20,30,10,20,30];
console.log(ary.indexOf(20));//1
console.log(ary.lastIndexOf(20));//4
可以使用该办法验证是否包含一个东西
if(ary.indexOf('珠峰')===-1){
console.log(&quot;不包含&quot;)
}else{
console.log(&quot;包含&quot;)
}

或则使用es6的inludes方法(ie6~8不兼容)
if(ary.includes(&quot;珠峰&quot;)){
    //如果包含返回true
}
</code></pre>
<h3 id="5数组的排序或则排列">5：数组的排序或则排列</h3>
<p><code>reverse</code></p>
<blockquote>
<p>reverse: 把数组倒过来排列</p>
<p>参数： 无</p>
<p>返回值：排列后的新数组，原数组改变</p>
</blockquote>
<pre><code class="language-javascript">let ary=[12,15,9,28,10,22];
ary.reverse;
console.log(ary);// [22,10,28,9,15,12]
</code></pre>
<p><code>sort</code></p>
<blockquote>
<p>sort: 实现数组的排序</p>
<p>参数：可以没有也可以是函数，但是如果不传递参数，是无法处理10以上的数字</p>
<p>返回值：排列后的新数组，原数组改变</p>
</blockquote>
<pre><code class="language-javascript">let ary=[7,8,5,1,6,4];
ary.sort();
console.log(ary);//[1, 4, 5, 6, 7, 8]

注意：sort如果不传递参数，是无法处理10以上的数字
let ary=[7,18,15,21,26,9];
ary.sort();
console.log(ary);//[15, 18, 21, 26, 7, 9] 它是按照第一个开头数字排序
修改：
let ary=[7,18,15,21,26,9];
ary.sort((a,b)=&gt;{
    //a,b是数组相邻两项
    //return a-b:从小到大排
    //return b-a:从大到小排
    return a-b;
});
console.log(ary);//[7, 9, 15, 18, 21, 26]
</code></pre>
<h3 id="6遍历数组的每一项的方法">6：遍历数组的每一项的方法</h3>
<p><code>foreach</code> <code>map</code>  <code>filter</code>   <code>find</code>  <code>reduce</code> <code>some</code> <code>every</code>  、、、</p>
<blockquote>
<p><code>foreach</code>: 遍历数组中的每一项内容</p>
<p>参数：函数</p>
<p>返回值： 没有</p>
<p>原数组不变</p>
</blockquote>
<p>基于原生js的循环可以实现</p>
<p>如：</p>
<pre><code class="language-javascript">let ary=[10,20,30,40];
for(var i=0;i&lt;ary.length;i++){
    console.log('索引:'+i+'内容:'+ary[i]);
}
</code></pre>
<p>下面使用foreach方法</p>
<pre><code class="language-javascript">let ary=[10,20,30,40];
ary.forEach(function(item,index){
    //数组有多少项,函数就会被默认执行多少次
    //每一次执行函数，item就是当前数组要操作的这一项（相当于上面原生js方法的ary[i]），index是当前项的索引（相当于上面原生js方法的i）
     console.log('索引:'+index+'内容:'+item);
});
</code></pre>
<h3 id="7案列数组去重">7案列：数组去重</h3>
<pre><code class="language-javascript"> &lt;script&gt;
      /*
      注意数组塌陷问题
       */
      /* 重建数组去重函数 */
      function unique(ary) {
        let obj = {}; //创建一个对象来存取item：item
        for (let i = 0; i &lt; ary.length; i++) {
          let item = ary[i];
          if (obj[item] !== undefined) {
            //代表这个数是重复的
            ary[i] = ary[ary.length - 1]; //让这个重复的数被最后一个数替换
            ary.length--;
            i--; //替换后继续检测这个位置的数，这里是数组塌陷问题
            continue;
          }
          obj[item] = item;
        }
        return ary;
      }
      let aa = [1, 2, 3, 1, 2, 3];
      aa = unique(aa);
      console.log(aa);

      /* 
      es6的方法
       */
      let bb = [1, 2, 3, 1, 2, 3];
      bb = [...new Set(bb)];
      console.log(bb);
    &lt;/script&gt;
</code></pre>
<p><img src="https://jianmu123.github.io//post-images/1601997762649.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601997776600.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS4]]></title>
        <id>https://jianmu123.github.io/post/js4/</id>
        <link href="https://jianmu123.github.io/post/js4/">
        </link>
        <updated>2020-10-05T14:15:44.000Z</updated>
        <content type="html"><![CDATA[<p>#基础知识回顾<br>
<img src="https://jianmu123.github.io//post-images/1601907580239.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907584911.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907588735.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907593796.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907607849.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907612064.jpg" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907630995.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907650988.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907657820.PNG" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907687373.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907691641.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS3]]></title>
        <id>https://jianmu123.github.io/post/js3/</id>
        <link href="https://jianmu123.github.io/post/js3/">
        </link>
        <updated>2020-10-04T12:07:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="js中的操作语句判断-循环">JS中的操作语句：判断、循环。</h3>
<blockquote>
<p>判断 ：</p>
<p>​			if/else if/else</p>
<p>​			三元运算符</p>
<p>​			switch case</p>
</blockquote>
<p>三元运算符： 条件？条件成立执行的事情：不成立执行的事情；</p>
<p>1：如果处理的事情多，我们用括号包起来，每一件事情用逗号分隔.</p>
<p>2:如果不需要处理事情，可以使用null/undefined占位.</p>
<p>上面2句说法的解释：</p>
<pre><code class="language-javascript">例如用if写一个判断,这里做了2件事情，并且不满足的时候什么事情都不做：
if (a&gt;0&amp;&amp;a&lt;10){
   a++;
   console.log(a);
}
它的三元运算符这样写：
a&gt;0&amp;&amp;a&lt;10 ? (a++,console.log(a)):null; 
//1：如果处理的事情多，我们用括号包起来，每一件事情用逗号分隔2:如果不需要处理事情，可以使用null/undefined占位.
</code></pre>
<h3 id="js中的函数">js中的函数</h3>
<blockquote>
<p>函数中的返回值：<br>
函数执行的时候，函数体内部创建的变量我们是无法获取和操作的，如果想要获取内部信息，需要使用return返回机制。返回的一定是一个值，不是变量。</p>
</blockquote>
<pre><code class="language-javascript">function sum(a,b){
    let result=a+b;
    //return的一定是值：此处是把result变量存储的值返回给外面
    return result;
}
sum(10,20);//是这个整体值为30，不是result值为30 
console.log(result);//会报错 Uncaught ReferenceError: result is not defined
如果没有写return，调用函数的默认返回值是undefined.
</code></pre>
<blockquote>
<p>函数体中遇到return 则后面的代码不会再运行。</p>
</blockquote>
<h3 id="arguments属性函数内置实参集合">arguments属性（函数内置实参集合）</h3>
<ul>
<li>类数组集合，集合中存储着所有函数执行时传递的实参信息。</li>
<li>不论是否设置形参，arguments都存在</li>
<li>不论是否传递实参，arguments也都存在</li>
</ul>
<p>案列：任意数求和</p>
<pre><code class="language-javascript">  &lt;script&gt;
      /*
        实际的加法运算是任意数相加，并没有规定多少个数，什么类型的数，因此下面写一个任意数相加的函数
         */
      function sum() {
        // console.log(arguments); //这里采用的函数arguments属性
        let total = null;
        for (let i = 0; i &lt; arguments.length; i++) {
          let item = arguments[i]; //获取每个值
          item = Number(item); //但是一些类型会转为NaN，所以还需要进一步处理

          if (isNaN(item)) {
            //非有效数字不进行加法运算，进行下一个数的判断
            continue;
          }
          /*
         但是样写如果传入的是字符串型或则其他类型就会输出字符串
          */
          total += item; //比如如果是30+'30'则是字符串拼接结果为'3030'，所以需要在计算前转换为Number
        }
        return total;
      }

      let result = sum(10, 20, 30);
      console.log(result);
      result = sum(10, 20);
      console.log(result);
      result = sum(10, 20, &quot;30&quot;);
      console.log(result);
      result = sum(10, 20, &quot;AA&quot;, 20);
      console.log(result);
    &lt;/script&gt;
</code></pre>
<h4 id="js函数运行底层机制">js函数运行底层机制</h4>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1601907056396.png" alt="" loading="lazy"></figure>
<p>——注意：执行几次函数就会产生几个全新的私有栈内存，因此涉及到内存释放与销毁。</p>
<h3 id="匿名函数">匿名函数</h3>
<p>匿名函数分为：函数表达式和自执行函数</p>
<ul>
<li>函数表达式：把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发，而是靠其他驱动程序触发执行（例如：触发某个事件的时候执行）</li>
</ul>
<p>如： document.body.onclick=function(){};</p>
<p>setTimeout(function(){},1000);//设置定时器，1000ms后执行匿名函数</p>
<ul>
<li>自执行函数： 能创建完一个匿名函数，紧接着就把当前函数加<strong>小括号</strong>执行</li>
</ul>
<p>如：</p>
<p>（function（n）{</p>
<p>​    //n=100</p>
<p>​     }）(100);</p>
<p>//这里的（100）执行了匿名函数，得到了n=100；</p>
<h3 id="for-in-循环">for in 循环</h3>
<blockquote>
<p>语法： for(var 变量（key）in 对象)</p>
</blockquote>
<pre><code class="language-javascript">var obj={
	name:'张三',
	age:18,
    friends:'李四',
    1:20,
    2:150
};
//使用for in循环能够遍历出对象的所有内容，对象有多少组键值对，循环就执行几次（除非添加break结束）
for (var key in obj){
    console.log(key);//每次循环key变量都存储着当前对象的属性名
    console.log(obj[key]);//获取属性值的办法
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1601907094800.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>代码详解：</p>
<pre><code class="language-javascript">var btnList=document.getElementsByTagName(&quot;btn&quot;);
for(var i=0;i&lt;btnList.length;i++){
    btnlist[i].onclick=function(){
        alert(i);//这里无论点击哪个按钮都是弹出序号：5
    }
}
改进：
var btnList=document.getElementsByTagName(&quot;btn&quot;);
for(var i=0;i&lt;btnList.length;i++){
    btnList[i].myIndex=i;//创建自定义属性给每个点击的btn贴上标签
    btnlist[i].onclick=function(){
        alert(this.myIndex);//这里就可以弹出点击的按钮的序号（索引）
    }
}
</code></pre>
</li>
</ul>
<p><img src="https://jianmu123.github.io//post-images/1601907107501.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601907114756.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS2]]></title>
        <id>https://jianmu123.github.io/post/js2/</id>
        <link href="https://jianmu123.github.io/post/js2/">
        </link>
        <updated>2020-10-02T13:23:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="js中的数据类型检测">js中的数据类型检测</h2>
<ul>
<li>typeof[val]:用来检测数据类型的运算符</li>
<li>instanceof :用来检测当前实列是否属于某个类</li>
<li>constructor：基于构造函数检测数据类型(也是基于类的方式)</li>
<li>Object.prototype.toString.call（）：检测数据类型最好的办法</li>
</ul>
<h4 id="一基于typeof检测的结果">一：基于typeof检测的结果</h4>
<ul>
<li>都是字符串</li>
<li>字符串中包含的是对应类型</li>
</ul>
<p>例如：console .log(typeof typeof typeof[]);</p>
<p>​       首先 typeof [] 返回 ”object“</p>
<p>​		然后 typeof ”object“ 返回 ”string“</p>
<p>​		最后typeof &quot;string&quot;返回”string“</p>
<p>​	   typeof NaN;//”number“</p>
<pre><code>  typeof null;//“object”

typeof {};//”object“

typeof [];//“object”

typeof /^$/;//”object“
</code></pre>
<p>typeof 的局限性：</p>
<p>​     -  typeof null的结果是object ，但是null不是对象只是空对象指针</p>
<p>​     -  typeof 无法细分出当前值是普通对象还是数组对象等，因为只要检测的是对象数据类型都返回”object“</p>
<h4 id="二-基于instanceof检测结果">二： 基于instanceof检测结果</h4>
<p>instanceof只能检测引用数据类型，对于基本类型不生效,返回值是true/false。并且它不能用于检测null和undefined。</p>
<pre><code class="language-javascript">例如：

 		console.log(&quot;1&quot; instanceof String); //false

 		console.log(1 instanceof Number); //false

 		console.log(true instanceof Boolean); //false

 		console.log([]  instanceof Array); //true

 		console.log({} instanceof Object); //true

 		console.log(function(){} instanceof Function); //true

</code></pre>
<h4 id="三-基于constructor检测结果">三： 基于constructor检测结果</h4>
<p>先看一下用法：</p>
<pre><code class="language-javascript">console.log((&quot;1&quot;).constructor===String);//true
console.log((1).constructor===Number;//true
console.log((true).constructor===Boolean);//true
console.log(([]).constructor===Array);//true
console.log(({}).constructor===Object);//true
console.log((function(){}).constructor===Fuction);//true
</code></pre>
<p>撇去null和undefined，可以看出constructor能用于检测js的基本类型和引用类型。但是设计到原型和继承的时候便会出现问题。如下</p>
<pre><code class="language-javascript">function fun(){};
    fun.prototype=new Array();
    let f=new fun();
	console.log(f.constructor===fun);//false
	console.log(f.constructor===Array);//ture
    
</code></pre>
<p>在这里，我们先是定义了一个函数fun，并将该函数的原型指向了数组，同时，声明了一个f为fun的类型，然后利用constructor进行检测时，结果如下：false  true;</p>
<h3 id="小结撇去null和undefinedconstructor能用于检测js的基本类型和引用类型但当对象的原型更改之后constructor便失效了">小结：撇去null和undefined，constructor能用于检测js的基本类型和引用类型，但当对象的原型更改之后，constructor便失效了。</h3>
<h4 id="四objectprototypetostringcall">四：Object.prototype.toString.call()</h4>
<p>用法：</p>
<pre><code>  ```javascript
</code></pre>
<p>console.log(Object.prototype.toString.call(&quot;str&quot;));<br>
console.log(Object.prototype.toString.call(1));<br>
console.log(Object.prototype.toString.call(true));<br>
console.log(Object.prototype.toString.call(null));<br>
console.log(Object.prototype.toString.call(undefined));<br>
console.log(Object.prototype.toString.call([]));<br>
console.log(Object.prototype.toString.call({}));<br>
console.log(Object.prototype.toString.call(function(){}));<br>
```</p>
<p>结果：</p>
<p>[Object String]</p>
<p>[Object Number]</p>
<p>[Object Boolean]</p>
<p>[Object null]</p>
<p>[Object undefined]</p>
<p>[Object Array]</p>
<p>[Object Object]</p>
<p>[Object Function]</p>
<p>这样一看，似乎能满足js的所有数据类型，那我们看下继承之后是否能检测出来</p>
<pre><code class="language-javascript">function fun(){};
    fun.prototype=new Array();
    let f=new fun();
	console.log(object.prototype.toString.call(fun));
	console.log(object.prototype.toString.call(f));
</code></pre>
<p>结果：</p>
<p>[Object Function]</p>
<p>[Object Object]</p>
<h3 id="可以看出objectprototypetostringcall可用于检测js所有的数据类型">可以看出，Object.prototype.toString.call()可用于检测js所有的数据类型。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS1]]></title>
        <id>https://jianmu123.github.io/post/js1/</id>
        <link href="https://jianmu123.github.io/post/js1/">
        </link>
        <updated>2020-10-01T13:06:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="js做客户端语言">JS做客户端语言</h3>
<blockquote>
<p>按照相关的js语法，再去操作页面的元素。4，有时还需要操作浏览器里面的一些功能》</p>
<ul>
<li>
<p>ECSAScript3/5/6...：JS的语法规范（变量、数据类型、操作语句等等）。</p>
</li>
<li>
<p>DOM(document object model):文档对象模型，提供一些JS的属性方法，用来操作页面的DOM元素。</p>
</li>
<li>
<p>BOM(browser object model):浏览器对象模型，提供一些JS的属性和方法，用来操作浏览器（比如：刷新，关闭等等）。</p>
</li>
</ul>
</blockquote>
<h3 id="js中的变量-variable">JS中的变量 variable</h3>
<blockquote>
<p>变量：可变的量，在编程语言中，变量就是一个名字，用来存储和代表不同的值的东西。</p>
</blockquote>
<pre><code class="language-javascript">//ES3
   var a=12;
 	   a=13;
   console.log(a);//=&gt;输出的a的值是13
//ES6
 	let b=100;
		b=200;
  const c=1000;
		c=2000;//会报错，因为const存储的值不能被修改（可以理解为常量）。
//创建函数也相当于创建变量
function fu(){}
//ES6中创建类也相当于在创建变量
class A{}
//ES6的模块导入也可以创建变量
import B from './B.js';//导入一个模块，创建一个B来存储
//Symbol创建唯一值
let n=Symbol(100);
let m=Symbol(100);
console.log(m==n);//false,因为是创建的唯一值
</code></pre>
<h3 id="js的命名规范">JS的命名规范</h3>
<ul>
<li>
<p>严格区分大小写</p>
</li>
<li>
<p>使用数字、字母、下划线、$,数字不能开头</p>
</li>
<li>
<p>使用驼峰命名法：首写字母小写，其余每一个有意义单词首字母大写</p>
</li>
</ul>
<h3 id="js中常用的数据类型">JS中常用的数据类型</h3>
<p>— 基本数据类型</p>
<ul>
<li>数字类型number（NaN也是数字类型）</li>
<li>字符串类型string</li>
<li>布尔类型boolean</li>
<li>空对象指针null</li>
<li>未定义类型undefined</li>
</ul>
<p>—引用数据类型</p>
<ul>
<li>
<p>对象数据类型object</p>
<p>​    {}：普通对象</p>
<p>​    []：数组对象</p>
<p>​    /^$/:正则对象</p>
<p>​    Math数学函数对象</p>
<p>日期对象</p>
<p>、、、</p>
</li>
<li>
<p>函数数据类型function</p>
</li>
</ul>
<h3 id="number数字类型">number数字类型</h3>
<blockquote>
<p>包含：常规数字和NaN</p>
</blockquote>
<h4 id="nan">NaN:</h4>
<p>不是一个数字，和任何值都不相等（包括自己）。NaN !=NaN，所以我们不能用相等的方式来判断是否是一个有效数字。</p>
<h4 id="isnan">isNaN</h4>
<blockquote>
<p>检测一个值是否是非有效数字，如果不是有效数字返回true，否则返回false。</p>
<p>语法：isNaN（[val]）</p>
</blockquote>
<pre><code class="language-console.log(isNaN(10));//false">console.log(isNaN(10));//false

console.log(isNaN('AA'));//true
//机制：Number('AA')=&gt;NaN
注意：
console.log(isNaN('10'));//false
//机制：Number('10')=&gt;10
isNaN的使用机制：首先看这个值是不是数字类型，如果不是则会使用Number()这个方法把值转换数字类型，然后再检测

</code></pre>
<h3 id="字符串转数字">字符串转数字</h3>
<blockquote>
<p>Number()方法把字符串转换为数字，只要字符串中包含任意一个非有效数字字符，结果都是NaN，空字符串会转换为数字0。</p>
</blockquote>
<pre><code class="language-javascript">console.log(Number('12.5'));//12.5
console.log(Number('12.5px'));//NaN
console.log(Number(''));//0
</code></pre>
<h3 id="布尔转数字">布尔转数字</h3>
<p>同样使用Number()方法，ture=&gt;1;false=&gt;0。</p>
<h3 id="空对象和undefined转数字">空对象和undefined转数字</h3>
<pre><code class="language-javascript">console.log(Number(null));//0

console.log(Number(undefined));//NaN
</code></pre>
<h3 id="引用数据类型转数字">引用数据类型转数字</h3>
<p>把引用数据类型先通过toString()方法转换为字符串，然后再通过Number()方法转换为数字。</p>
<pre><code class="language-javascript">对象
console.log(Number({number:'xxx'}));//NaN
console.log(Number({}));//NaN
//toString()方法转为object
数组
console.log(Number([]);//0
//toSting()转为空字符串&quot;&quot;,然后Number()把它转为0
console.log(Number([12]);//12
//toSting()转为&quot;12&quot;
console.log(Number([12,23]);//NaN
//toSting()转为&quot;12,23&quot;,含有非有效数字字符（逗号）
</code></pre>
<h3 id="把其他类型值转换为数字类型">把其他类型值转换为数字类型</h3>
<ul>
<li>Number([val])</li>
<li>parseInt([val]，[进制])  //返回整数</li>
<li>parseFloat([val]，[进制]) //返回浮点数<br>
后面两种方法对字符串来说是从左到右一次查找有效字符，直到遇到非有效字符，就停止查找（无论后面是否还有有效数字都会停止），然后返回查找的数字。</li>
</ul>
<pre><code class="language-javascript">let str='12.5px'
console.log(Number(str);// NaN
console.log(parseInt(tsr));//12
console.log(parseFloat(str));//12.5
</code></pre>
<p>== 进行比较的时候，可能会把其他类型转换为数字<br>
比如：console.log('10'==10);//true</p>
<h3 id="其他类型转换为字符串">其他类型转换为字符串</h3>
<ul>
<li>[val].toString()</li>
<li>字符串拼接</li>
</ul>
<p>null和undefined是禁止直接使用toString的 。</p>
<p>加号有四则运算的功能和字符串拼接的功能，只有遇到字符串才是字符串拼接的功能。</p>
<pre><code class="language-javascript">console.log('10'+10);  =&gt;'1010'
let a=10+null+true+[12]+undefined+'珠峰'+null+[]+10+false;
/*
 10+null=10+0=10
 10+true=10+1=11
 11+[12]=11+'12'='1112' 遇到字符串直接进行字符串拼接，之后所有+号都是拼接
 '1112'+undefined='1112undefined'
 '1112undefined'+'珠峰'='1112undefined珠峰'
 '1112undefined珠峰'+null='1112undefined珠峰null'
 '1112undefined珠峰null'+[]='1112undefined珠峰null'  空数组转为空字符串
 '1112undefined珠峰null'+10+false='1112undefined珠峰null10false'
*/
console.log(a); =&gt;'1112undefined珠峰null10false'
</code></pre>
<h2 id="boolean布尔数据类型">boolean布尔数据类型</h2>
<blockquote>
<p>只有两个值 true/false</p>
</blockquote>
<h3 id="把其它类型值转换为布尔类型">把其它类型值转换为布尔类型</h3>
<blockquote>
<p>只有0、NaN、''、null、undefined这5个值转换为false（没有任何其他情况）</p>
</blockquote>
<pre><code class="language-javascript">console.log(Boolean(0));//false
console.log(Boolean(''));//false
console.log(Boolean(' '));//ture,因为里面不是空字符串，而是一个空格
console.log(Boolean(null));//false
console.log(Boolean(undefined));//false
console.log(Boolean(NaN));//false
console.log(Boolean([]));//ture
console.log(Boolean([12]));//ture
</code></pre>
<p>转换方法：</p>
<ul>
<li>Boolean()</li>
<li>!或则!! （ 一个！表示取反，2个表示取2次反）</li>
<li>条件判断</li>
</ul>
<h2 id="object对象数据类型-普通对象">object对象数据类型-普通对象</h2>
<blockquote>
<p>{[key]:[value],....} 任何一个对象都是有零到多对键值对（属性名:属性值）组成的（并且属性名不能重复）。</p>
</blockquote>
<pre><code class="language-javascript">let person={
    name: '孙悟空',
    age:18,
    height:'185cm'
}
//获取值：
      对象.属性名 如：person.name
或则： 对象[属性名] 如：person['name']
属性名是数字或则字符串格式，如果属性名是数字则只能使用第二种方法获取

真删除：delete.person.age;
假删除：person.age=null;(属性还在，值为空)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 One]]></title>
        <id>https://jianmu123.github.io/post/css3-one/</id>
        <link href="https://jianmu123.github.io/post/css3-one/">
        </link>
        <updated>2020-10-01T06:50:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一盒子模型">一：盒子模型</h1>
<p>以前的盒子的大小是盒子的本身加上padding+border+margin，因此盒子的大小不会是我们设置的大小，这样还需要去计算来设置我们想要的盒子大小，现在css3添加了盒子模型，这样的盒子大小就是我们设置的盒子大小。只需要在盒子的样式中添加：box-sizing：border-box；</p>
<h1 id="二盒子阴影">二：盒子阴影</h1>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1601535646649.png" alt="" loading="lazy"></figure>
<h1 id="三渐变">三：渐变</h1>
<p><img src="https://jianmu123.github.io//post-images/1601906334140.png" alt="" loading="lazy"><br>
镜像渐变<br>
<img src="https://jianmu123.github.io//post-images/1601906339746.png" alt="" loading="lazy"><br>
重复渐变<br>
<img src="https://jianmu123.github.io//post-images/1601906418113.png" alt="" loading="lazy"><br>
#四：背景图片<br>
<img src="https://jianmu123.github.io//post-images/1601906437901.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601906442586.png" alt="" loading="lazy"></p>
<h1 id="五多列布局">五：多列布局</h1>
<p><img src="https://jianmu123.github.io//post-images/1601906656788.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601906666863.png" alt="" loading="lazy"></p>
<h1 id="六盒子模型">六：盒子模型</h1>
<p><img src="https://jianmu123.github.io//post-images/1601906687547.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601906693246.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601906702206.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML5 Two]]></title>
        <id>https://jianmu123.github.io/post/html5-two/</id>
        <link href="https://jianmu123.github.io/post/html5-two/">
        </link>
        <updated>2020-10-01T05:27:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一进度条">一：进度条</h1>
<pre><code class="language-HTML">&lt;progress&gt; 和&lt;meter&gt; 标签是 HTML 5 中的新标签。
请结合 &lt;progress&gt; 标签与 JavaScript 一同使用，来显示任务的进度。
属性：max，min
&lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1601530514020.png" alt="" loading="lazy"></figure>
<h1 id="二上传文件及时预览的制作">二：上传文件及时预览的制作</h1>
<p>及时：当用户选择完图片后，立即进行预览的处理<br>
预览：通过文件读取对象的readAsDataURL()完成。<br>
上传文件表单属性：type=&quot;file&quot;。<br>
<img src="https://jianmu123.github.io//post-images/1601531304633.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601531310321.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1601531315021.png" alt="" loading="lazy"></p>
<h1 id="三拖拽">三：拖拽</h1>
<p>拖拽的事件：<br>
ondrag  :应用于拖拽元素，整个拖拽过程都会调用。<br>
ondragstart  :应用于拖拽元素，拖拽开始时调用。<br>
ondragleave :应用于拖拽元素，鼠标离开拖拽元素时调用。<br>
ondragend :应用于拖拽元素，拖拽结束时调用。</p>
<h1 id="四存储方式">四：存储方式</h1>
<p>1：sessionStorage：<br>
特点：<br>
存储数据到本地，存储容量位5mb左右。<br>
这个数据本质时存储在当前页面的内存种。<br>
它生命周期位关闭当前页面就会自动清除数据。<br>
2：localStorage：<br>
特点：<br>
存储大小20mb左右。<br>
不会随着浏览器关闭而消失，它会永久保存。如果想清除，必须手动清。<br>
它们的属性方法：<br>
setItem(key,value):存储数据，以键值对的方式存储.<br>
getItem(key):获取数据，通过指定的名称键值获取对应的value值。<br>
removeItem(key):删除输出，输出指定名称的对应value值。<br>
clear():清空所有存储的内容。<br>
<img src="https://jianmu123.github.io//post-images/1601534950413.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML5 one]]></title>
        <id>https://jianmu123.github.io/post/html5-one/</id>
        <link href="https://jianmu123.github.io/post/html5-one/">
        </link>
        <updated>2020-09-28T14:27:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1html5新增语义化标签">1:HTML5新增语义化标签</h1>
<pre><code class="language-HTML"> &lt;header&gt;,&lt;footer&gt;, &lt;article&gt;, &lt;section&gt;,&lt;nav&gt;,&lt;main&gt;
</code></pre>
<h1 id="2html5新的表单控件">2:HTML5新的表单控件:</h1>
<pre><code class="language-javascript">邮箱：type=&quot;email&quot; 
提供了默认的电子邮箱的完整验证：要求必须含有@符号，同时必须包含服务器名称,如果不能满足验证，则会阻止当前的数据提交。
电话：type=&quot;tel&quot;
tel并不是用来验证手机号的，它的本质目的是能够在移动端打开数字键盘，意味着数字键盘限制了用户只能输入数字。
网址：type=&quot;url&quot;
验证是否是一个合法的网址（必须包含http://）
数量：type=&quot;number&quot;
number:只能输入数字（可以包含小数点）,不能输入其他字符
可以设置max：最大值，min：最小值，value：默认值
输入：type=&quot;search&quot;
提供一个更好的输入化体验，即：在表单框最后有一个×，点击了可以直接删除所有内容
范围 :typr=&quot;range&quot;
可以设置max，min和默认值value
颜色：type=&quot;color&quot;
可以选择颜色
日期时间相关：
时分秒：type=&quot;time&quot; 年月日：type=&quot;date&quot;  年月日时分秒：type=&quot;datetime-local&quot;
月份：type=&quot;month&quot; 星期：type=&quot;week&quot;
选取文件：type=&quot;file&quot;  它的multiple属性是可以一次选取多个文件
</code></pre>
<h1 id="3下拉列表">3：下拉列表</h1>
<p>以前使用select标签和option标签制作下拉列表，但是它不能让用户手动输入文本，新增了datalist的标签，结合input和option使用，必须与input的list属性进行关联绑定它可以使用户手动输入。<br>
所有主流浏览器都支持 <datalist> 标签，除了 Internet Explorer 和 Safari。<br>
<img src="https://jianmu123.github.io//post-images/1601529507046.png" alt="" loading="lazy"></p>
<h1 id="4表单的属性">4:表单的属性：</h1>
<pre><code class="language-javascript">placeholder :表单默认提示文本
autofocus:自动获取焦点
autocomplete:自动显示之前提交过的信息，赋值on：表示打开，赋值off，表示关闭，该属性还需要配合表单的name属性和提交控件，name属性需要赋予一个值，然后完成提交才会在下一次点击表单的时候
显示提交过的信息
requride:表示这个表单必须输入内容
pattern：给定一个正则表达式复习正则表达式：
* ：表示任意一个 
?：表示0个或则1个
+：表示1个或则多个
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1601362793168.png" alt="" loading="lazy"></figure>
<h1 id="5表单事件">5：表单事件</h1>
<p>oninput事件：监听当前指定元素的内容，只要内容有改变，便会触发该事件。<br>
onkeyup事件：键盘弹起触发，每弹起一次就会触发一次。<br>
oninvalid事件：当验证不通过的时候触发。这里提及一下setCustomValidity属性，可以设置提示文本。<br>
<img src="https://jianmu123.github.io//post-images/1601529982670.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery5]]></title>
        <id>https://jianmu123.github.io/post/jquery5/</id>
        <link href="https://jianmu123.github.io/post/jquery5/">
        </link>
        <updated>2020-09-24T13:30:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1jquery事件处理">1：jQuery事件处理</h2>
<h3 id="1-elementon方法可以绑定多个事件">1： element.on()方法可以绑定多个事件</h3>
<p>语法：element.on(event,[selector],fn);<br>
event是事件类型，[selector]是元素的子元素选择器<br>
您的浏览器不支持 video 标签。<br>
</video></p>
<pre><code class="language-javascript">    $(&quot;div&quot;).on({
        //鼠标经过div背景变红
        mouseenter：function(){
        $(&quot;this&quot;).css(&quot;background&quot;,&quot;red&quot;);
       },
       //鼠标点击div背景变粉红
      click：function(){
          $(&quot;this&quot;).css(&quot;background&quot;,&quot;pink&quot;);
      }
    })
</code></pre>
<p>on方法可以实现事件的委派。例如：</p>
<pre><code class="language-javascript">$(&quot;ul&quot;).on(click,&quot;li&quot;,function(){
    alert(&quot;触发了点击事件&quot;);
});
这个触发事件在ul上，但是触发对象在li上，即ul委托li帮他触发
</code></pre>
<h3 id="2off方法可以移除通过on方法添加的事件处理程序">2:off方法可以移除通过on方法添加的事件处理程序</h3>
<pre><code class="language-javascript"> $(&quot;p&quot;).off()  //解除p上所有的事件处理
 $(&quot;p&quot;).off(&quot;click&quot;) //解除p上的click事件处理
 $(&quot;ul&quot;).off(&quot;click&quot;，&quot;li&quot;) //解除事件委托
</code></pre>
<h3 id="3自动触发事件">3:自动触发事件</h3>
<p>有些事件希望自动触发，比如轮播图的自动播放能跟点击按钮一致，可以利用定时器自动触发按钮按钮点击事件，不必鼠标点击触发。<br>
第一种形式：元素.事件()<br>
第二种形式：元素.trigger(&quot;事件&quot;)<br>
第三种形式：元素.triggerHandler(&quot;事件&quot;)<br>
第三种和前面的区别：不会触发元素的默认行为，比如文本框焦点事件的光标此时不会闪烁</p>
<pre><code class="language-javascript">       下面代码不会有光标闪烁：
       $(&quot;input&quot;).on(&quot;focus&quot;,function(){
           $(&quot;this&quot;).val(&quot;你好吗&quot;);
       })
       $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);//自动触发
</code></pre>
<h3 id="4阻止默认行为和冒泡行为">4：阻止默认行为和冒泡行为</h3>
<h4 id="41阻止默认行为eventpreventdefault-或则return-false">4.1:阻止默认行为：event.preventDefault(); 或则：return false</h4>
<h4 id="42阻止冒泡行为eventstoppropagation">4.2:阻止冒泡行为：event.stopPropagation()</h4>
<p>###5:jQuery对象拷贝<br>
语法：$.extend([deep],target,object1,[objectN]) //[objectN]是代表不仅可以拷贝一个还可以拷贝多个。<br>
<img src="https://jianmu123.github.io//post-images/1600956466981.png" alt="" loading="lazy"><br>
浅拷贝：会覆盖原来数据<br>
深拷贝：会保留原来是数据<br>
<img src="https://jianmu123.github.io//post-images/1600957628103.png" alt="" loading="lazy"><br>
<img src="https://jianmu123.github.io//post-images/1600957634129.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery4]]></title>
        <id>https://jianmu123.github.io/post/jquery4/</id>
        <link href="https://jianmu123.github.io/post/jquery4/">
        </link>
        <updated>2020-09-23T13:07:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一jquery元素操作">一jQuery元素操作</h2>
<h3 id="1找父级元素可以通过parent方法但是当父级元素很多的时候可以使用partens方法该方法会获取到所有的祖先元素包括body和html结合siblings方法可以找到该元素所需要的祖先元素">1：找父级元素可以通过parent()方法，但是当父级元素很多的时候可以使用partens()方法，该方法会获取到所有的祖先元素，包括body和html，结合siblings()方法可以找到该元素所需要的祖先元素。</h3>
<pre><code class="language-javascript">  例如:
  var p = $(this).panrent(&quot;.quantity-form&quot;).parent(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();等同于：  var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
</code></pre>
<h3 id="2遍历">2:遍历</h3>
<p>隐式迭代是对同一类元素做了相同的操作，如果想要给同一类元素左不同的操作则需要使用遍历。<br>
遍历使用的是each()方法和$.each()方法。</p>
<h4 id="each方法主要使用在遍历dom对象比如标签">each()方法主要使用在遍历DOM对象，比如标签</h4>
<figure data-type="image" tabindex="1"><img src="https://jianmu123.github.io//post-images/1600867180840.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">   $(&quot;div&quot;).each(function (index, domEle) {
          //回调函数的第一个参数一定是索引号，可以是自己定义的索引名称
          console.log(index); //结果： 0 1 2
          //回调函数的第二个参数一定是DOM对象,可以是自己定义的对象名称
          console.log(domEle); //结果：&lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;
          //domEle.cc(&quot;color&quot;);//会报错，因为DOM对象没有css方法，因此需要转换成JQ对象
          $(&quot;domEle&quot;).css(&quot;color&quot;, &quot;bule&quot;);
        });
</code></pre>
<h4 id="each方法主要是来处理数据的比如数组-对象">$.each()方法：主要是来处理数据的，比如数组、对象。</h4>
<figure data-type="image" tabindex="2"><img src="https://jianmu123.github.io//post-images/1600868203421.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">        var arr = [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;]; //定义数组
        //遍历数组
        $.each(arr, function (index, domEle) {
          console.log(index); //打印索引0 1 2
          console.log(domEle); //打印arr内部值 blue red green
        });
        //遍历对象
        $.each(
          {
            name: &quot;孙悟空&quot;,
            age: 18,
          },
          function (i, ele) {
            console.log(i); //输出name age属性名
            console.log(ele); //输出顺悟空 18属性值
          }
        );
</code></pre>
<h3 id="3创建添加删除元素">3:创建添加删除元素</h3>
<p>创建语法：var li=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">&quot;</mi><mo>&lt;</mo><mi>l</mi><mi>i</mi><mo>&gt;</mo><mi mathvariant="normal">我</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">的</mi><mi>l</mi><mi>i</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mo>&gt;</mo><mi mathvariant="normal">&quot;</mi><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">语</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">：</mi><mo>(</mo><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">匹</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mo>)</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">匹</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mi>u</mi><mi>l</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">原</mi><mi mathvariant="normal">有</mi><mi>l</mi><mi>i</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi><mi>l</mi><mi>i</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">(&quot;&lt;li&gt;我是创建的li&lt;/li&gt;&quot;);
添加语法：内部添加：(添加后是匹配元素的子元素)
       elelment. append()方法，会添加到匹配元素的后面。在ul中原有li后面添加li使用方法：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">语</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">：</span><span class="mopen">(</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mclose">)</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">原</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">：</span></span></span></span>(&quot;ul&quot;).append(li);<br>
elelment.prepend()方法，会添加到匹配元素的前面。在ul中原有li前面添加li使用方法：$(&quot;ul&quot;).prepend(li);<br>
外部添加：(添加后是匹配元素的兄弟元素)<br>
elelment.before()和 elelment.after()。<br>
删除元素:<br>
element.remove();删除匹配元素本身。<br>
element.empty();删除匹配元素集合中的所有子节点。<br>
element.html(&quot;&quot;);清空匹配元素内容。</p>
]]></content>
    </entry>
</feed>