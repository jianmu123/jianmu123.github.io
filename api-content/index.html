{"posts":[{"title":"JS4","content":"#基础知识回顾 ","link":"https://jianmu123.github.io/post/js4/"},{"title":"JS3","content":"JS中的操作语句：判断、循环。 判断 ： ​ if/else if/else ​ 三元运算符 ​ switch case 三元运算符： 条件？条件成立执行的事情：不成立执行的事情； 1：如果处理的事情多，我们用括号包起来，每一件事情用逗号分隔. 2:如果不需要处理事情，可以使用null/undefined占位. 上面2句说法的解释： 例如用if写一个判断,这里做了2件事情，并且不满足的时候什么事情都不做： if (a&gt;0&amp;&amp;a&lt;10){ a++; console.log(a); } 它的三元运算符这样写： a&gt;0&amp;&amp;a&lt;10 ? (a++,console.log(a)):null; //1：如果处理的事情多，我们用括号包起来，每一件事情用逗号分隔2:如果不需要处理事情，可以使用null/undefined占位. js中的函数 函数中的返回值： 函数执行的时候，函数体内部创建的变量我们是无法获取和操作的，如果想要获取内部信息，需要使用return返回机制。返回的一定是一个值，不是变量。 function sum(a,b){ let result=a+b; //return的一定是值：此处是把result变量存储的值返回给外面 return result; } sum(10,20);//是这个整体值为30，不是result值为30 console.log(result);//会报错 Uncaught ReferenceError: result is not defined 如果没有写return，调用函数的默认返回值是undefined. 函数体中遇到return 则后面的代码不会再运行。 arguments属性（函数内置实参集合） 类数组集合，集合中存储着所有函数执行时传递的实参信息。 不论是否设置形参，arguments都存在 不论是否传递实参，arguments也都存在 案列：任意数求和 &lt;script&gt; /* 实际的加法运算是任意数相加，并没有规定多少个数，什么类型的数，因此下面写一个任意数相加的函数 */ function sum() { // console.log(arguments); //这里采用的函数arguments属性 let total = null; for (let i = 0; i &lt; arguments.length; i++) { let item = arguments[i]; //获取每个值 item = Number(item); //但是一些类型会转为NaN，所以还需要进一步处理 if (isNaN(item)) { //非有效数字不进行加法运算，进行下一个数的判断 continue; } /* 但是样写如果传入的是字符串型或则其他类型就会输出字符串 */ total += item; //比如如果是30+'30'则是字符串拼接结果为'3030'，所以需要在计算前转换为Number } return total; } let result = sum(10, 20, 30); console.log(result); result = sum(10, 20); console.log(result); result = sum(10, 20, &quot;30&quot;); console.log(result); result = sum(10, 20, &quot;AA&quot;, 20); console.log(result); &lt;/script&gt; js函数运行底层机制 ——注意：执行几次函数就会产生几个全新的私有栈内存，因此涉及到内存释放与销毁。 匿名函数 匿名函数分为：函数表达式和自执行函数 函数表达式：把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发，而是靠其他驱动程序触发执行（例如：触发某个事件的时候执行） 如： document.body.onclick=function(){}; setTimeout(function(){},1000);//设置定时器，1000ms后执行匿名函数 自执行函数： 能创建完一个匿名函数，紧接着就把当前函数加小括号执行 如： （function（n）{ ​ //n=100 ​ }）(100); //这里的（100）执行了匿名函数，得到了n=100； for in 循环 语法： for(var 变量（key）in 对象) var obj={ name:'张三', age:18, friends:'李四', 1:20, 2:150 }; //使用for in循环能够遍历出对象的所有内容，对象有多少组键值对，循环就执行几次（除非添加break结束） for (var key in obj){ console.log(key);//每次循环key变量都存储着当前对象的属性名 console.log(obj[key]);//获取属性值的办法 } 代码详解： var btnList=document.getElementsByTagName(&quot;btn&quot;); for(var i=0;i&lt;btnList.length;i++){ btnlist[i].onclick=function(){ alert(i);//这里无论点击哪个按钮都是弹出序号：5 } } 改进： var btnList=document.getElementsByTagName(&quot;btn&quot;); for(var i=0;i&lt;btnList.length;i++){ btnList[i].myIndex=i;//创建自定义属性给每个点击的btn贴上标签 btnlist[i].onclick=function(){ alert(this.myIndex);//这里就可以弹出点击的按钮的序号（索引） } } ","link":"https://jianmu123.github.io/post/js3/"},{"title":"JS2","content":"js中的数据类型检测 typeof[val]:用来检测数据类型的运算符 instanceof :用来检测当前实列是否属于某个类 constructor：基于构造函数检测数据类型(也是基于类的方式) Object.prototype.toString.call（）：检测数据类型最好的办法 一：基于typeof检测的结果 都是字符串 字符串中包含的是对应类型 例如：console .log(typeof typeof typeof[]); ​ 首先 typeof [] 返回 ”object“ ​ 然后 typeof ”object“ 返回 ”string“ ​ 最后typeof &quot;string&quot;返回”string“ ​ typeof NaN;//”number“ typeof null;//“object” typeof {};//”object“ typeof [];//“object” typeof /^$/;//”object“ typeof 的局限性： ​ - typeof null的结果是object ，但是null不是对象只是空对象指针 ​ - typeof 无法细分出当前值是普通对象还是数组对象等，因为只要检测的是对象数据类型都返回”object“ 二： 基于instanceof检测结果 instanceof只能检测引用数据类型，对于基本类型不生效,返回值是true/false。并且它不能用于检测null和undefined。 例如： console.log(&quot;1&quot; instanceof String); //false console.log(1 instanceof Number); //false console.log(true instanceof Boolean); //false console.log([] instanceof Array); //true console.log({} instanceof Object); //true console.log(function(){} instanceof Function); //true 三： 基于constructor检测结果 先看一下用法： console.log((&quot;1&quot;).constructor===String);//true console.log((1).constructor===Number;//true console.log((true).constructor===Boolean);//true console.log(([]).constructor===Array);//true console.log(({}).constructor===Object);//true console.log((function(){}).constructor===Fuction);//true 撇去null和undefined，可以看出constructor能用于检测js的基本类型和引用类型。但是设计到原型和继承的时候便会出现问题。如下 function fun(){}; fun.prototype=new Array(); let f=new fun(); console.log(f.constructor===fun);//false console.log(f.constructor===Array);//ture 在这里，我们先是定义了一个函数fun，并将该函数的原型指向了数组，同时，声明了一个f为fun的类型，然后利用constructor进行检测时，结果如下：false true; 小结：撇去null和undefined，constructor能用于检测js的基本类型和引用类型，但当对象的原型更改之后，constructor便失效了。 四：Object.prototype.toString.call() 用法： ```javascript console.log(Object.prototype.toString.call(&quot;str&quot;)); console.log(Object.prototype.toString.call(1)); console.log(Object.prototype.toString.call(true)); console.log(Object.prototype.toString.call(null)); console.log(Object.prototype.toString.call(undefined)); console.log(Object.prototype.toString.call([])); console.log(Object.prototype.toString.call({})); console.log(Object.prototype.toString.call(function(){})); ``` 结果： [Object String] [Object Number] [Object Boolean] [Object null] [Object undefined] [Object Array] [Object Object] [Object Function] 这样一看，似乎能满足js的所有数据类型，那我们看下继承之后是否能检测出来 function fun(){}; fun.prototype=new Array(); let f=new fun(); console.log(object.prototype.toString.call(fun)); console.log(object.prototype.toString.call(f)); 结果： [Object Function] [Object Object] 可以看出，Object.prototype.toString.call()可用于检测js所有的数据类型。 ","link":"https://jianmu123.github.io/post/js2/"},{"title":"JS1","content":"JS做客户端语言 按照相关的js语法，再去操作页面的元素。4，有时还需要操作浏览器里面的一些功能》 ECSAScript3/5/6...：JS的语法规范（变量、数据类型、操作语句等等）。 DOM(document object model):文档对象模型，提供一些JS的属性方法，用来操作页面的DOM元素。 BOM(browser object model):浏览器对象模型，提供一些JS的属性和方法，用来操作浏览器（比如：刷新，关闭等等）。 JS中的变量 variable 变量：可变的量，在编程语言中，变量就是一个名字，用来存储和代表不同的值的东西。 //ES3 var a=12; a=13; console.log(a);//=&gt;输出的a的值是13 //ES6 let b=100; b=200; const c=1000; c=2000;//会报错，因为const存储的值不能被修改（可以理解为常量）。 //创建函数也相当于创建变量 function fu(){} //ES6中创建类也相当于在创建变量 class A{} //ES6的模块导入也可以创建变量 import B from './B.js';//导入一个模块，创建一个B来存储 //Symbol创建唯一值 let n=Symbol(100); let m=Symbol(100); console.log(m==n);//false,因为是创建的唯一值 JS的命名规范 严格区分大小写 使用数字、字母、下划线、$,数字不能开头 使用驼峰命名法：首写字母小写，其余每一个有意义单词首字母大写 JS中常用的数据类型 — 基本数据类型 数字类型number（NaN也是数字类型） 字符串类型string 布尔类型boolean 空对象指针null 未定义类型undefined —引用数据类型 对象数据类型object ​ {}：普通对象 ​ []：数组对象 ​ /^$/:正则对象 ​ Math数学函数对象 日期对象 、、、 函数数据类型function number数字类型 包含：常规数字和NaN NaN: 不是一个数字，和任何值都不相等（包括自己）。NaN !=NaN，所以我们不能用相等的方式来判断是否是一个有效数字。 isNaN 检测一个值是否是非有效数字，如果不是有效数字返回true，否则返回false。 语法：isNaN（[val]） console.log(isNaN(10));//false console.log(isNaN('AA'));//true //机制：Number('AA')=&gt;NaN 注意： console.log(isNaN('10'));//false //机制：Number('10')=&gt;10 isNaN的使用机制：首先看这个值是不是数字类型，如果不是则会使用Number()这个方法把值转换数字类型，然后再检测 字符串转数字 Number()方法把字符串转换为数字，只要字符串中包含任意一个非有效数字字符，结果都是NaN，空字符串会转换为数字0。 console.log(Number('12.5'));//12.5 console.log(Number('12.5px'));//NaN console.log(Number(''));//0 布尔转数字 同样使用Number()方法，ture=&gt;1;false=&gt;0。 空对象和undefined转数字 console.log(Number(null));//0 console.log(Number(undefined));//NaN 引用数据类型转数字 把引用数据类型先通过toString()方法转换为字符串，然后再通过Number()方法转换为数字。 对象 console.log(Number({number:'xxx'}));//NaN console.log(Number({}));//NaN //toString()方法转为object 数组 console.log(Number([]);//0 //toSting()转为空字符串&quot;&quot;,然后Number()把它转为0 console.log(Number([12]);//12 //toSting()转为&quot;12&quot; console.log(Number([12,23]);//NaN //toSting()转为&quot;12,23&quot;,含有非有效数字字符（逗号） 把其他类型值转换为数字类型 Number([val]) parseInt([val]，[进制]) //返回整数 parseFloat([val]，[进制]) //返回浮点数 后面两种方法对字符串来说是从左到右一次查找有效字符，直到遇到非有效字符，就停止查找（无论后面是否还有有效数字都会停止），然后返回查找的数字。 let str='12.5px' console.log(Number(str);// NaN console.log(parseInt(tsr));//12 console.log(parseFloat(str));//12.5 == 进行比较的时候，可能会把其他类型转换为数字 比如：console.log('10'==10);//true 其他类型转换为字符串 [val].toString() 字符串拼接 null和undefined是禁止直接使用toString的 。 加号有四则运算的功能和字符串拼接的功能，只有遇到字符串才是字符串拼接的功能。 console.log('10'+10); =&gt;'1010' let a=10+null+true+[12]+undefined+'珠峰'+null+[]+10+false; /* 10+null=10+0=10 10+true=10+1=11 11+[12]=11+'12'='1112' 遇到字符串直接进行字符串拼接，之后所有+号都是拼接 '1112'+undefined='1112undefined' '1112undefined'+'珠峰'='1112undefined珠峰' '1112undefined珠峰'+null='1112undefined珠峰null' '1112undefined珠峰null'+[]='1112undefined珠峰null' 空数组转为空字符串 '1112undefined珠峰null'+10+false='1112undefined珠峰null10false' */ console.log(a); =&gt;'1112undefined珠峰null10false' boolean布尔数据类型 只有两个值 true/false 把其它类型值转换为布尔类型 只有0、NaN、''、null、undefined这5个值转换为false（没有任何其他情况） console.log(Boolean(0));//false console.log(Boolean(''));//false console.log(Boolean(' '));//ture,因为里面不是空字符串，而是一个空格 console.log(Boolean(null));//false console.log(Boolean(undefined));//false console.log(Boolean(NaN));//false console.log(Boolean([]));//ture console.log(Boolean([12]));//ture 转换方法： Boolean() !或则!! （ 一个！表示取反，2个表示取2次反） 条件判断 object对象数据类型-普通对象 {[key]:[value],....} 任何一个对象都是有零到多对键值对（属性名:属性值）组成的（并且属性名不能重复）。 let person={ name: '孙悟空', age:18, height:'185cm' } //获取值： 对象.属性名 如：person.name 或则： 对象[属性名] 如：person['name'] 属性名是数字或则字符串格式，如果属性名是数字则只能使用第二种方法获取 真删除：delete.person.age; 假删除：person.age=null;(属性还在，值为空) ","link":"https://jianmu123.github.io/post/js1/"},{"title":"CSS3 One","content":"一：盒子模型 以前的盒子的大小是盒子的本身加上padding+border+margin，因此盒子的大小不会是我们设置的大小，这样还需要去计算来设置我们想要的盒子大小，现在css3添加了盒子模型，这样的盒子大小就是我们设置的盒子大小。只需要在盒子的样式中添加：box-sizing：border-box； 二：盒子阴影 三：渐变 镜像渐变 重复渐变 #四：背景图片 五：多列布局 六：盒子模型 ","link":"https://jianmu123.github.io/post/css3-one/"},{"title":"HTML5 Two","content":"一：进度条 &lt;progress&gt; 和&lt;meter&gt; 标签是 HTML 5 中的新标签。 请结合 &lt;progress&gt; 标签与 JavaScript 一同使用，来显示任务的进度。 属性：max，min &lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。 二：上传文件及时预览的制作 及时：当用户选择完图片后，立即进行预览的处理 预览：通过文件读取对象的readAsDataURL()完成。 上传文件表单属性：type=&quot;file&quot;。 三：拖拽 拖拽的事件： ondrag :应用于拖拽元素，整个拖拽过程都会调用。 ondragstart :应用于拖拽元素，拖拽开始时调用。 ondragleave :应用于拖拽元素，鼠标离开拖拽元素时调用。 ondragend :应用于拖拽元素，拖拽结束时调用。 四：存储方式 1：sessionStorage： 特点： 存储数据到本地，存储容量位5mb左右。 这个数据本质时存储在当前页面的内存种。 它生命周期位关闭当前页面就会自动清除数据。 2：localStorage： 特点： 存储大小20mb左右。 不会随着浏览器关闭而消失，它会永久保存。如果想清除，必须手动清。 它们的属性方法： setItem(key,value):存储数据，以键值对的方式存储. getItem(key):获取数据，通过指定的名称键值获取对应的value值。 removeItem(key):删除输出，输出指定名称的对应value值。 clear():清空所有存储的内容。 ","link":"https://jianmu123.github.io/post/html5-two/"},{"title":"HTML5 one","content":"1:HTML5新增语义化标签 &lt;header&gt;,&lt;footer&gt;, &lt;article&gt;, &lt;section&gt;,&lt;nav&gt;,&lt;main&gt; 2:HTML5新的表单控件: 邮箱：type=&quot;email&quot; 提供了默认的电子邮箱的完整验证：要求必须含有@符号，同时必须包含服务器名称,如果不能满足验证，则会阻止当前的数据提交。 电话：type=&quot;tel&quot; tel并不是用来验证手机号的，它的本质目的是能够在移动端打开数字键盘，意味着数字键盘限制了用户只能输入数字。 网址：type=&quot;url&quot; 验证是否是一个合法的网址（必须包含http://） 数量：type=&quot;number&quot; number:只能输入数字（可以包含小数点）,不能输入其他字符 可以设置max：最大值，min：最小值，value：默认值 输入：type=&quot;search&quot; 提供一个更好的输入化体验，即：在表单框最后有一个×，点击了可以直接删除所有内容 范围 :typr=&quot;range&quot; 可以设置max，min和默认值value 颜色：type=&quot;color&quot; 可以选择颜色 日期时间相关： 时分秒：type=&quot;time&quot; 年月日：type=&quot;date&quot; 年月日时分秒：type=&quot;datetime-local&quot; 月份：type=&quot;month&quot; 星期：type=&quot;week&quot; 选取文件：type=&quot;file&quot; 它的multiple属性是可以一次选取多个文件 3：下拉列表 以前使用select标签和option标签制作下拉列表，但是它不能让用户手动输入文本，新增了datalist的标签，结合input和option使用，必须与input的list属性进行关联绑定它可以使用户手动输入。 所有主流浏览器都支持 标签，除了 Internet Explorer 和 Safari。 4:表单的属性： placeholder :表单默认提示文本 autofocus:自动获取焦点 autocomplete:自动显示之前提交过的信息，赋值on：表示打开，赋值off，表示关闭，该属性还需要配合表单的name属性和提交控件，name属性需要赋予一个值，然后完成提交才会在下一次点击表单的时候 显示提交过的信息 requride:表示这个表单必须输入内容 pattern：给定一个正则表达式复习正则表达式： * ：表示任意一个 ?：表示0个或则1个 +：表示1个或则多个 5：表单事件 oninput事件：监听当前指定元素的内容，只要内容有改变，便会触发该事件。 onkeyup事件：键盘弹起触发，每弹起一次就会触发一次。 oninvalid事件：当验证不通过的时候触发。这里提及一下setCustomValidity属性，可以设置提示文本。 ","link":"https://jianmu123.github.io/post/html5-one/"},{"title":"jQuery5","content":"1：jQuery事件处理 1： element.on()方法可以绑定多个事件 语法：element.on(event,[selector],fn); event是事件类型，[selector]是元素的子元素选择器 您的浏览器不支持 video 标签。 $(&quot;div&quot;).on({ //鼠标经过div背景变红 mouseenter：function(){ $(&quot;this&quot;).css(&quot;background&quot;,&quot;red&quot;); }, //鼠标点击div背景变粉红 click：function(){ $(&quot;this&quot;).css(&quot;background&quot;,&quot;pink&quot;); } }) on方法可以实现事件的委派。例如： $(&quot;ul&quot;).on(click,&quot;li&quot;,function(){ alert(&quot;触发了点击事件&quot;); }); 这个触发事件在ul上，但是触发对象在li上，即ul委托li帮他触发 2:off方法可以移除通过on方法添加的事件处理程序 $(&quot;p&quot;).off() //解除p上所有的事件处理 $(&quot;p&quot;).off(&quot;click&quot;) //解除p上的click事件处理 $(&quot;ul&quot;).off(&quot;click&quot;，&quot;li&quot;) //解除事件委托 3:自动触发事件 有些事件希望自动触发，比如轮播图的自动播放能跟点击按钮一致，可以利用定时器自动触发按钮按钮点击事件，不必鼠标点击触发。 第一种形式：元素.事件() 第二种形式：元素.trigger(&quot;事件&quot;) 第三种形式：元素.triggerHandler(&quot;事件&quot;) 第三种和前面的区别：不会触发元素的默认行为，比如文本框焦点事件的光标此时不会闪烁 下面代码不会有光标闪烁： $(&quot;input&quot;).on(&quot;focus&quot;,function(){ $(&quot;this&quot;).val(&quot;你好吗&quot;); }) $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);//自动触发 4：阻止默认行为和冒泡行为 4.1:阻止默认行为：event.preventDefault(); 或则：return false 4.2:阻止冒泡行为：event.stopPropagation() ###5:jQuery对象拷贝 语法：$.extend([deep],target,object1,[objectN]) //[objectN]是代表不仅可以拷贝一个还可以拷贝多个。 浅拷贝：会覆盖原来数据 深拷贝：会保留原来是数据 ","link":"https://jianmu123.github.io/post/jquery5/"},{"title":"jQuery4","content":"一jQuery元素操作 1：找父级元素可以通过parent()方法，但是当父级元素很多的时候可以使用partens()方法，该方法会获取到所有的祖先元素，包括body和html，结合siblings()方法可以找到该元素所需要的祖先元素。 例如: var p = $(this).panrent(&quot;.quantity-form&quot;).parent(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();等同于： var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); 2:遍历 隐式迭代是对同一类元素做了相同的操作，如果想要给同一类元素左不同的操作则需要使用遍历。 遍历使用的是each()方法和$.each()方法。 each()方法主要使用在遍历DOM对象，比如标签 $(&quot;div&quot;).each(function (index, domEle) { //回调函数的第一个参数一定是索引号，可以是自己定义的索引名称 console.log(index); //结果： 0 1 2 //回调函数的第二个参数一定是DOM对象,可以是自己定义的对象名称 console.log(domEle); //结果：&lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; //domEle.cc(&quot;color&quot;);//会报错，因为DOM对象没有css方法，因此需要转换成JQ对象 $(&quot;domEle&quot;).css(&quot;color&quot;, &quot;bule&quot;); }); $.each()方法：主要是来处理数据的，比如数组、对象。 var arr = [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;]; //定义数组 //遍历数组 $.each(arr, function (index, domEle) { console.log(index); //打印索引0 1 2 console.log(domEle); //打印arr内部值 blue red green }); //遍历对象 $.each( { name: &quot;孙悟空&quot;, age: 18, }, function (i, ele) { console.log(i); //输出name age属性名 console.log(ele); //输出顺悟空 18属性值 } ); 3:创建添加删除元素 创建语法：var li=(&quot;&lt;li&gt;我是创建的li&lt;/li&gt;&quot;);添加语法：内部添加：(添加后是匹配元素的子元素)elelment.append()方法，会添加到匹配元素的后面。在ul中原有li后面添加li使用方法：(&quot;&lt;li&gt;我是创建的li&lt;/li&gt;&quot;); 添加语法：内部添加：(添加后是匹配元素的子元素) elelment. append()方法，会添加到匹配元素的后面。在ul中原有li后面添加li使用方法：(&quot;&lt;li&gt;我是创建的li&lt;/li&gt;&quot;);添加语法：内部添加：(添加后是匹配元素的子元素)elelment.append()方法，会添加到匹配元素的后面。在ul中原有li后面添加li使用方法：(&quot;ul&quot;).append(li); elelment.prepend()方法，会添加到匹配元素的前面。在ul中原有li前面添加li使用方法：$(&quot;ul&quot;).prepend(li); 外部添加：(添加后是匹配元素的兄弟元素) elelment.before()和 elelment.after()。 删除元素: element.remove();删除匹配元素本身。 element.empty();删除匹配元素集合中的所有子节点。 element.html(&quot;&quot;);清空匹配元素内容。 ","link":"https://jianmu123.github.io/post/jquery4/"},{"title":"jQuery3","content":"一:jQuery属性操作 ###1：设置或获取元素固有属性值：prop() 所谓元素固有属性值就是元素本身自带的属性，比如标签中的herf。 2：设置或获取元素自定义属性值：attr() 3:数据缓存 data() data()方法可以在指定元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前的存放的数据都会被移除 购物车案列（不含css部分） &lt;body&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;!-- 全选模块 --&gt; &lt;div class=&quot;t-checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;checkall&quot; /&gt;全选 &lt;/div&gt; &lt;div class=&quot;t-goods&quot;&gt;商品&lt;/div&gt; &lt;div class=&quot;t-price&quot;&gt;单价&lt;/div&gt; &lt;div class=&quot;t-num&quot;&gt;数量&lt;/div&gt; &lt;div class=&quot;t-sum&quot;&gt;小计&lt;/div&gt; &lt;/div&gt; &lt;!-- 商品模块 --&gt; &lt;div class=&quot;cart-item-list&quot;&gt; &lt;div class=&quot;cart-check&quot;&gt; &lt;div class=&quot;p-checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;p-goodes&quot;&gt; &lt;div class=&quot;p-img&quot;&gt; &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt; 洗衣粉 &lt;/div&gt; &lt;div class=&quot;p-price&quot;&gt;￥12.60&lt;/div&gt; &lt;div class=&quot;p-num&quot;&gt; &lt;div class=&quot;quantity-form&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt; &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;p-sum&quot;&gt;￥12.60&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;cart-item-list&quot;&gt; &lt;div class=&quot;cart-check&quot;&gt; &lt;div class=&quot;p-checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;p-goodes&quot;&gt; &lt;div class=&quot;p-img&quot;&gt; &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt; 消毒水 &lt;/div&gt; &lt;div class=&quot;p-price&quot;&gt;￥15.20&lt;/div&gt; &lt;div class=&quot;p-num&quot;&gt; &lt;div class=&quot;quantity-form&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt; &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;p-sum&quot;&gt;￥15.20&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;cart-item-list&quot;&gt; &lt;div class=&quot;cart-check&quot;&gt; &lt;div class=&quot;p-checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;j-checkbox&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;p-goodes&quot;&gt; &lt;div class=&quot;p-img&quot;&gt; &lt;!-- &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; --&gt; 吹风机 &lt;/div&gt; &lt;div class=&quot;p-price&quot;&gt;￥30.50&lt;/div&gt; &lt;div class=&quot;p-num&quot;&gt; &lt;div class=&quot;quantity-form&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;decrement&quot;&gt;-&lt;/a&gt; &lt;input type=&quot;text&quot; class=&quot;itxt&quot; value=&quot;1&quot; style=&quot;width: 20px&quot; /&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;increment&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;p-sum&quot;&gt;￥30.50&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 总计模块 --&gt; &lt;div class=&quot;cart-floatbar&quot;&gt; &lt;div class=&quot;select-all&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;checkall&quot; /&gt;全选 &lt;/div&gt; &lt;div class=&quot;operation&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;remove-batch&quot;&gt;删除选中的商品&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;clear-all&quot;&gt;清除购物车&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;toolbar-right&quot;&gt; &lt;div class=&quot;amount-sum&quot;&gt;总计&lt;em&gt; &lt;/em&gt;件商品&lt;/div&gt; &lt;div class=&quot;price-sum&quot;&gt;总价：&lt;em&gt;￥&lt;/em&gt;&lt;/div&gt; &lt;div class=&quot;btn-area&quot;&gt; &lt;a href=&quot;javascript:;&quot; style=&quot;color: red&quot;&gt;去结算&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //实现点击全选框，所有商品全选，或则手动点击了所有商品选中框，上面全选框也选上 $(function () { //入口函数 //1：全选点击单选框，可以用change事件 $(&quot;.checkall&quot;).change(function () { // var a = $(this).prop(&quot;checked&quot;); // console.log(a);//结果是点击全选返回ture,证明已经获取到 $(&quot;.j-checkbox, .checkall&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;)); //下面的按钮根据全选的状态变化而变化 //所有商品背景变化 if ($(this).prop(&quot;checked&quot;)) { $(&quot;.cart-item-list&quot;).addClass(&quot;beijing&quot;); } else { $(&quot;.cart-item-list&quot;).removeClass(&quot;beijing&quot;); } }); $(&quot;.j-checkbox&quot;).change(function () { //如果下面的复选框全部选中，则上面的全选也选中$(&quot;.j-checkbox&quot;).length是所有商品的单选框数量 if ($(&quot;.j-checkbox:checked&quot;).length == $(&quot;.j-checkbox&quot;).length) { //.j-checkbox:checked可以知道到底有几个单选框被选中 $(&quot;.checkall&quot;).prop(&quot;checked&quot;, true); } else { $(&quot;.checkall&quot;).prop(&quot;checked&quot;, false); } if ($(this).prop(&quot;checked&quot;)) { $(this).parents(&quot;.cart-item-list&quot;).addClass(&quot;beijing&quot;); } else { $(this).parents(&quot;.cart-item-list&quot;).removeClass(&quot;beijing&quot;); } }); // 2：增减商品数量模块。核心思路：声明一个变量，当我们点击+/-的时候，就让这个值++/--，然后赋给文本框 $(&quot;.increment&quot;).click(function () { //得到当前加/减的兄弟：文本框的值 var n = $(this).siblings(&quot;.itxt&quot;).val(); //text文本使用val获取内容 // console.log(n); n++; $(this).siblings(&quot;.itxt&quot;).val(n); // 3: 根据商品数量自动计算价格,价格是加减号的父亲的父亲的兄弟 var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); // console.log(p); p = p.substr(1) * n; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算 p = p.toFixed(2); // console.log(p); $(this) .parents(&quot;.p-num&quot;) .siblings(&quot;.p-sum&quot;) .html(&quot;￥&quot; + p); getSum(); }); //3:减： $(&quot;.decrement&quot;).click(function () { var n = $(this).siblings(&quot;.itxt&quot;).val(); //text文本使用val获取内容，非文本使用text() // console.log(n); if (n &gt; 1) { n--; } $(this).siblings(&quot;.itxt&quot;).val(n); // 根据商品数量自动计算价格,价格是加减号的父亲的父亲的兄弟 var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); //获取到了价格 // console.log(p); p = p.substr(1) * n; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算 p = p.toFixed(2); $(this) .parents(&quot;.p-num&quot;) .siblings(&quot;.p-sum&quot;) .html(&quot;￥&quot; + p); getSum(); }); //4:手动修改文本框的数值使小计跟着改变 $(&quot;.itxt&quot;).change(function () { var m = $(this).val(); // console.log(m); var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); p = p.substr(1) * m; //去掉索引为0的美元符号,截取后面的价格,然后队小计进行计算 p = p.toFixed(2); $(this) .parents(&quot;.p-num&quot;) .siblings(&quot;.p-sum&quot;) .html(&quot;￥&quot; + p); getSum(); }); getSum(); //初始显示选中商品总数和总价 //5:商品总数模块,定义一个函数，来遍历商品数量和总价 function getSum() { var count = 0; var money = 0; //获取文本框数量,使用each遍历方法 $(&quot;.itxt&quot;).each(function (index, ele) { //index是索引，ele是dom对象 // console.log(index); // console.log($(ele)); count += parseInt($(ele).val()); }); //修改总数量 $(&quot;.amount-sum em&quot;).text(count); //获取总价 $(&quot;.p-sum&quot;).each(function (index, ele) { money += parseFloat($(ele).text().substr(1)); // console.log(sum); //修改总价钱 $(&quot;.price-sum em&quot;).text(&quot;￥&quot; + money.toFixed(2)); }); } // 6:删除模块 $(&quot;.remove-batch&quot;).click(function () { //删除复选框选中的商品 $(&quot;.j-checkbox:checked&quot;).parents(&quot;.cart-item-list&quot;).remove(); getSum(); }); //清空购物车模块 $(&quot;.clear-all&quot;).click(function () { $(&quot;.cart-item-list&quot;).remove(); getSum(); }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://jianmu123.github.io/post/jquery3/"},{"title":"jQuery-2","content":"一：jQuery的样式操作 1：设置类样式方法 作用等同于以前的classList，可以操作类样式，注意jQuery中的类参数不要加点。 添加类：$(&quot;div&quot;).addClass(&quot;current&quot;);//这里是给div盒子添加current的类 删除类：$(&quot;div&quot;).removeClss(&quot;current&quot;);//这里是删除div盒子current的类 切换类：$(&quot;div&quot;).toggleClss(&quot;current&quot;);//这里是切换div盒子current的类 &lt;script&gt; $(function () { //添加类addClass $(&quot;div&quot;).click(function () { $(this).addClass(&quot;current&quot;); }); //删除类removeClass $(&quot;div&quot;).click(function () { $(this).removeClass(&quot;current&quot;); }); //切换类toggleClass $(&quot;div&quot;).click(function () { $(this).toggleClass(&quot;current&quot;); }); }); &lt;/script&gt; 2:jQuery的类操作是对指定类进行操作，不会影响原先类名，但是原生js中className会覆盖元素里面原先的类名。 下面做一个菜单栏案例：点击菜单后该菜单的内容显示出来，单击其他菜单，之前显示的菜单隐藏。 二：jQuery效果 1：显示/隐藏 /切换：show([speed],[easing],[callback]) hide([speed],[easing],[callback]) toggle([speed],[easing],[callback])。注意这3个方法内部有方括号[],所以参数都可以不写。 2：下拉/上啦/切换: slideDown,slideUp,slideToggle。内部参数与上方一样。 3：事件切换：hover（[over],out） over:鼠标经过元素上触发，相当于mouseenter out:鼠标移出此元素要触发的函数，相当于mouseleave 区分概念： 1.mouseover与mouseout成对，mouseenter与mouseleave成对 2.mouseover触发优先级高于mouseenter，mouseout触发优先级mouseleave 3.在父元素上绑定mouseover和mouseout事件，子元素同样也会触发，即子元素事件会冒泡至父元素；而父元素绑定mouseenter和mouseleave事件只对父元素有效，子元素不会触发。 4：淡入淡出效果：fadeIn（）、fadeOut()、fadeToggle()、fadeTo(speed,opacity)。内部参数与上方一样。 4:自定义动画：animate(params，[speed]、[easing]、[callback])。 5：注意以上所有动画或效果都有动画队列的问题。 问题：动画或则效果一旦触发就会运行，但是当我们多次触发就会造成多个动画或效果的队列问题。 解决办法：在添加stop()方法，把上一个动画效果停止（谁执行了动画效果就在谁前面添加）。 ","link":"https://jianmu123.github.io/post/jquery-2/"},{"title":"jQuery-1","content":"一： jQuery的概述 1. jQuery是javaScript的一个封装库,里面存放了很多函数。 2. 使用时只需调用这个库文件。 3. jQuery主要是用来操作DOM的。 4. 学习jQuery的本质是学习调用这些函数。 二：jQuery的基本使用 1：首先官网下载[jQuery官网]{https://jquery.com/} 2：$符号是jQuery的别称，jQuery中的顶级对象，相当于javaScript中的window对象 3：注意下列： //下面是jQuery入口函数 &lt;script&gt; $(function () { //内容写这里 }); &lt;/script&gt; // 1:DOM 对象：用原生js方式获取的对象是DOM对象 var myDiv = document.querySelector(&quot;div&quot;); //querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。 console.dir(myDiv); //打印所有的属性和方法 // 2:jQuery 对象：用原生jQuery方式获取的对象是jQuery对象 $(&quot;div&quot;); // jQuery 对象 console.dir($(&quot;div&quot;)); // 从控制台可以看出2者打印的内容不同，jQuery打印了一个伪数组的形式 // 3:jQuery对象只能使用jQuery方法,DOM对象只能使用原生javaScript属性和方法,2者不能混用 4：jQuery对象和DOM对象的相互转换 因为原生js比jQuery大，一些原生的js属性方法在jQuery中没有，所以需要把jQuery对象转换为DOM对象才可以使用。 先用2种方式获取对象： var myDiv = document.querySelector(&quot;div&quot;);//DOM对象 $(&quot;div&quot;); // jQuery 对象 //jQuery转DOM(2种方式): $('div')[index];//index是索引号，因为jQuery对象是一个伪数组 $('div')get（index）; //DOM转jQuery： $(myDiv); 三：jQuery的常用API 1：jQuery基础选择器 $('选择器')；//里面选择器直接写CSS选择器即可，但是要加引号。 名称 用法 描述 ID选择器 $(&quot;#id&quot;) 获取指定的ID元素 全选选择器 $('*') 匹配所有元素 类选择器 $(&quot;.class&quot;) 获取同一类元素 标签选择器 $(&quot;div&quot;) 获取同一类标签的所有元素 并集选择器 $(&quot;div,p,li&quot;) 选取多个元素 交集选择器 $(&quot;li.current&quot;) 交集元素 2:jQuery设置css样式： $(&quot;div&quot;).css(&quot;属性&quot;,&quot;值&quot;);//例如：$(&quot;div&quot;).css(''background'',''red'');就把所有的div背景改为了红色 注意：这里的属性名一定要加引号 同时修改多个样式：使用对象的形式，注意这个时候属性名就不用加引号,加上也没错 $(&quot;div&quot;).css({ width:400, height:400, backgroundColor：&quot;red&quot;， 注意如果是复合属性就要写成驼峰命名法，如果值不是数字则必须使用引号 }) 这个里面有一个隐式迭代的概念，他会把所有选取到的所有元素进行循环遍历，依次执行相应的方法。 3：jQuery筛选选择器 语法 用法 :firsr $('li':first) 获取第一个li元素 :last $('li:last') 获取最后一个li元素 :eq(index) $(&quot;li:eq(2)&quot;) 获取到的li元素中，选择索引号为2的元素 (注意索引号是从0开始的) :odd $(&quot;li:odd&quot;) 获取到的li元素中，选择索引号为奇数的元素 :even $(&quot;li:even&quot;) 获取到的li元素中，选择索引号为偶数的元素 4：筛选方法（注意方法都有括号） 5：注意下例的写法： //让鼠标经过div使ul显示出来,this是当前元素(即:div) $(&quot;div&quot;).mousemove(function () { $(this).children(&quot;ul&quot;).show(); }); //鼠标移出就隐藏 $(&quot;div&quot;).mouseout(function(){ $(this).children(&quot;ul&quot;).hide(); }) ","link":"https://jianmu123.github.io/post/jquery1/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 本站是我的一个前端学习的博客，记录了我的前端学习的内容笔记，由于写博客的时候刚学jQuery，所以会从这里开始，你可以阅读我的笔记，如果可以帮助到你那我就非常开心😃。 ","link":"https://jianmu123.github.io/post/about/"}]}